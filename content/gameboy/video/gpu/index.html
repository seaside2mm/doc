<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="seaside">
  <link rel="canonical" href="https://seaside2mm.github.io/doc/content/gameboy/video/gpu/">
  <link rel="shortcut icon" href="../../../../img/favicon.ico">
  <title>GB-视频-GPU 寄存器与内存结构 - seaside</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../../../css/theme.css" />
  <link rel="stylesheet" href="../../../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  <link href="../../../../css/accu.css" rel="stylesheet" />
    
  
  <script>
    // Current page data
    var mkdocs_page_name = "GB-\u89c6\u9891-GPU \u5bc4\u5b58\u5668\u4e0e\u5185\u5b58\u7ed3\u6784";
    var mkdocs_page_input_path = "content/gameboy/video/gpu.md";
    var mkdocs_page_url = "/doc/content/gameboy/video/gpu/";
  </script>
  
  <script src="../../../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
    <script data-ad-client="ca-pub-5236818090688638" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../../../.." class="icon icon-home"> seaside</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../..">主页</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">数字图像处理</span></p>
                <ul>
                    <li class="toctree-l1"><a class="" href="../../../pil/channel.md">数字图像处理-通道</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/mean.md">数字图像处理-均值</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/contrast.md">数字图像处理-对比增强</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/contrast_tensile.md">数字图像处理-对比拉伸</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/bit.md">数字图像处理-位图切割</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/histogram_equalization.md">数字图像处理-直方图均衡化</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/sub.md">数字图像处理-图像减法</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/agwn.md">数字图像处理-加性高斯白噪声与去噪</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/spatial_filter.md">数字图像处理-空间滤波基础</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/spatial_filter_mean.md">数字图像处理-空间滤波-均值滤波</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/spatial_filter_medium.md">数字图像处理-空间滤波-中值滤波</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/spatial_filter_sharpening.md">数字图像处理-空间滤波-锐化滤波</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/spatial_filter_gaussian_blur.md">数字图像处理-空间滤波-高斯滤波</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/frequency_filter.md">数字图像处理-频域滤波基础</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/frequency_filter_lpf.md">数字图像处理-频域滤波-低通滤波</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/frequency_filter_hpf.md">数字图像处理-频域滤波-高通滤波</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/frequency_filter_br_bp.md">数字图像处理-频域滤波-带阻和带通滤波</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/noise.md">数字图像处理-噪声</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/safe_color.md">数字图像处理-安全色</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/macaron_color.md">数字图像处理-马卡龙色</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/complementary_and_invert_color.md">数字图像处理-补色和反色</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/watermark.md">数字图像处理-水印</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/resize_nearst.md">数字图像处理-缩放-最近邻插值法</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/resize_nearst_ghost.md">数字图像处理-缩放-最近邻插值法的幽灵事件</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/resize_bilinear.md">数字图像处理-缩放-双线性算法</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/resize_bicubic.md">数字图像处理-缩放-双三次插值法</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/ascii.md">数字图像处理-字符画</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/pil_tutorial_overview.md">Python-PIL-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/pil_image.md">Python-PIL-Image</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/pil_imagechops.md">Python-PIL-ImageChops</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/pil_imagecolor.md">Python-PIL-ImageColor</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/pil_imagedraw.md">Python-PIL-ImageDraw</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/pil_imageenhance.md">Python-PIL-ImageEnhance</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../pil/pil_imageops.md">Python-PIL-ImageOps</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">自己动手写 Game Boy 仿真器</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../../preface/">GB-前言</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../history/emulator/">GB-虚拟机发展史-硬件仿真器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../history/runtime/">GB-虚拟机发展史-程序虚拟机</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../history/simulator/">GB-虚拟机发展史-软件模拟器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cartridge/about_cartridge/">GB-游戏卡带-漫谈卡带</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cartridge/cartridge_header/">GB-游戏卡带-Header</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cartridge/memory_bank_controller/">GB-游戏卡带-Memory Bank Controller</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cartridge/rom_only/">GB-游戏卡带-ROM only</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cartridge/mbc1/">GB-游戏卡带-MBC1</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cartridge/mbc2/">GB-游戏卡带-MBC2</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cartridge/mbc3/">GB-游戏卡带-MBC3</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cartridge/mbc5/">GB-游戏卡带-MBC5</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cartridge/others/">GB-游戏卡带-完整代码</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cpu/overview/">GB-CPU-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cpu/alu/">GB-CPU-算术逻辑单元</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cpu/register/">GB-CPU-寄存器与存储系统</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cpu/isa/">GB-CPU-指令与指令集</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cpu/pipeline/">GB-CPU-流水线</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cpu/lr35902_standard/">GB-CPU-LR35902标准指令集</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cpu/lr35902_extension/">GB-CPU-LR35902扩展指令集</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cpu/cycles/">GB-CPU-LR35902时钟周期与频率仿真</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cpu/interrupts/">GB-CPU-LR35902中断</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cpu/mmu/">GB-CPU-内存管理单元与主板</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../overview/">GB-视频-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../dot_matrix/">GB-视频-点阵图</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../show/">GB-视频-显示输出</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../crt/">GB-视频-光栅成像原理与概念</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../system/">GB-视频-图像显示系统</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">GB-视频-GPU 寄存器与内存结构</a>
    <ul class="current">
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../code/">GB-视频-代码实现</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/overview/">GB-音频-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/sound/">GB-音频-声音的构成</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/cpal/">GB-音频-Rust Cpal 库介绍</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/concept/">GB-音频-音频系统概念简介</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/register/">GB-音频-寄存器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/timer/">GB-音频-512 Hz 时钟信号</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/frame_sequence/">GB-音频-序列发生器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/length_counter/">GB-音频-长度计数器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/vol/">GB-音频-音量包络</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/frequency_sweep/">GB-音频-频率扫描器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/square/">GB-音频-方波通道 1 & 2</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/wave/">GB-音频-可编程波形通道</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/noise/">GB-音频-白噪音通道</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/mixer/">GB-音频-混频器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/play/">GB-音频-在计算机上播放</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../other/joypad/">GB-其他-游戏手柄</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../other/serial/">GB-其他-串行通行接口</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../other/timer/">GB-其他-定时器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../other/init/">GB-其他-硬件初始化工作</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../other/test/">GB-其他-测试</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../foot/">GB-后记</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">算法</span></p>
                <ul>
                    <li class="toctree-l1"><a class="" href="../../../daze/ga/sga.md">遗传算法-简单遗传算法</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/ga/sga_optret.md">遗传算法-最优保留策略</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/ga/evolve.md">遗传算法-生物进化模拟</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/ga/fooled_nn.md">遗传算法-愚弄神经网络</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/dlib/install.md">Dlib-安装</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/dlib/face_detect.md">Dlib-人脸检测</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/dlib/face_landmark.md">Dlib-人脸标注</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/dlib/face_recognition.md">Dlib-人脸识别</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/dlib/face_clustering.md">Dlib-人脸聚类</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/rc4/overview.md">加密算法-RC4-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/rc4/performance_testing.md">加密算法-RC4-性能测试</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/game_of_life/overview.md">生命游戏</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/sklearn/overview.md">sklearn-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/sklearn/liner_model/overview.md">sklearn-线性模型-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/sklearn/liner_model/linear_regression.md">sklearn-线性模型-普通最小二乘法</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/sklearn/liner_model/ridge.md">sklearn-线性模型-岭回归</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/sklearn/liner_model/logistic_regression.md">sklearn-线性模型-逻辑回归</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/sklearn/tree.md">sklearn-决策树</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/sklearn/bayes.md">sklearn-贝叶斯分类器</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/sklearn/knn.md">sklearn-kNN</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/sklearn/cluster.md">sklearn-聚类</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/sklearn/svm.md">sklearn-SVM</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/sklearn/manifold.md">sklearn-流形学习</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/sklearn/evaluation.md">sklearn-评估</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/ml/neural_style_transfer.md">机器学习-图像风格转移</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/ml/fasttext.md">机器学习-快速文本分类</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/ml/hog.md">机器学习-HOG</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/math/huffman.md">Math-霍夫曼编码</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/math/variance_and_sd.md">Math-方差与标准差</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/math/normal_distribution.md">Math-正态分布</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../daze/math/kelly_formula.md">Math-凯利公式</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">语言</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/np/split/">Python-np-分割与合并</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/plt/line/">Python-matplotlib-折线图</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/plt/scatter/">Python-matplotlib-散点图</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/plt/bar/">Python-matplotlib-柱状图</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/plt/pie/">Python-matplotlib-饼图</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/f_string/">Python-f-string</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/ctypes/overview/">Python-windows编程-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/ctypes/recycle/">Python-windows编程-删除文件至回收站</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/setup/">Python-打包并发布代码至 PyPI</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/pywasm/overview/">Python-pywasm-美味尝鲜</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/pywasm/leb128/">Python-pywasm-LEB128</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/read_file/">Go-按行读取文件</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/socket/">Go-socket</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/socket_not_accept/">Go-socket-假如服务端不调用 Accept</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/tls/">Go-tls</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/socks5/">Go-socks-version-5</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/cross_compiling/">Go-交叉编译</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/end_of_time/">Go-时间尽头</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/token_bucket/">Go-流量限制</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/fswatch/">Go-目录监听</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/cgo/">Go-Cgo</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../ahk/overview/">AHK-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../ahk/clicker/">AHK-实现鼠标连点器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../ahk/color/">AHK-实现屏幕取色器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../ahk/longpress/">AHK-长按</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../ahk/loopread/">AHK-按行读取文件</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../rust/overview.md">Rust-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../rust/io.md">Rust-文件读取</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../rust/http.md">Rust-HTTP</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../rust/concurrent.md">Rust-并发</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../rust/tcp.md">Rust-TCP</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../rust/json.md">Rust-JSON</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">区块链</span></p>
                <ul>
                    <li class="toctree-l1"><a class="" href="../../../blockchain/evm.md">EVM</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../blockchain/merkle_tree.md">Merkle Tree</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">竹书纪年</span></p>
                <ul>
                    <li class="toctree-l1"><a class="" href="../../../diary/2019.md">Y2019</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../diary/2020.md">Y2020</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">演讲</span></p>
                <ul>
                    <li class="toctree-l1"><a class="" href="../../../speech/minits.md">minits, 以 LLVM 为后端的 TypeScript 静态编译器</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="../../../speech/blockchain_privacy_protection.md">区块链隐私保护密码技术介绍</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../..">seaside</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../..">Docs</a> &raquo;</li>
    
      
        
          <li>自己动手写 Game Boy 仿真器 &raquo;</li>
        
      
    
    <li>GB-视频-GPU 寄存器与内存结构</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="gpu">GPU 寄存器与内存结构</h1>
<p>GPU 在图像渲染中需要管理一些额外的状态数据, 比如在光栅成像过程中记录当前已经渲染了到第几行第几列. 这些数据均保存在 GPU 寄存器之内, CPU 可以通过修改寄存器来控制 GPU 的行为. GPU 所拥有的寄存器数量较多, 本节将对此进行一一解释.</p>
<p>GPU 寄存器总览:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>地址</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>LCD Control Register(LCDC)</td>
<td>0xff40</td>
<td>LCD 控制寄存器</td>
</tr>
<tr>
<td>LCD Status Register</td>
<td>0xff41</td>
<td>LCD 状态寄存器</td>
</tr>
<tr>
<td>Scroll Y(SCY)</td>
<td>0xff42</td>
<td>Scroll Y 寄存器</td>
</tr>
<tr>
<td>Scroll X(SCX)</td>
<td>0xff43</td>
<td>Scroll X 寄存器</td>
</tr>
<tr>
<td>LCDC Y-Coordinate(LY)</td>
<td>0xff44</td>
<td>当前数据传输到 LCD 驱动器的垂直线</td>
</tr>
<tr>
<td>LY Compare(LYC)</td>
<td>0xff45</td>
<td>用于和 LY 进行比较的值</td>
</tr>
<tr>
<td>Window Y Position(WY)</td>
<td>0xff4a</td>
<td>Window Y 寄存器</td>
</tr>
<tr>
<td>Window X Position(WX)</td>
<td>0xff4b</td>
<td>Window X 寄存器</td>
</tr>
<tr>
<td>BG Palette Data(BGP)</td>
<td>0xff47</td>
<td>为 BG 和 Window 图块的颜色编号分配灰色阴影, 非 CGB 模式专用</td>
</tr>
<tr>
<td>Object Palette 0 Data(OBP0)</td>
<td>0xff48</td>
<td>sprite 调色板 0, 非 CGB 模式专用</td>
</tr>
<tr>
<td>Object Palette 1 Data(OBP1)</td>
<td>0xff49</td>
<td>sprite 调色板 1, 非 CGB 模式专用</td>
</tr>
<tr>
<td>Background Palette Index(BCPS/BGPI)</td>
<td>0xff68</td>
<td>Background Palette Index, CGB 模式专用</td>
</tr>
<tr>
<td>Background Palette Data(BCPD/BGPD)</td>
<td>0xff69</td>
<td>Background Palette Data, CGB 模式专用</td>
</tr>
<tr>
<td>Sprite Palette Index(OCPS/OBPI)</td>
<td>0xff6a</td>
<td>Sprite Palette Index, CGB 模式专用</td>
</tr>
<tr>
<td>Sprite Palette Data(OCPD/OBPD)</td>
<td>0xff6b</td>
<td>Sprite Palette Data, CGB 模式专用</td>
</tr>
<tr>
<td>DMA Transfer and Start Address(DMA)</td>
<td>0xff46</td>
<td>DMA 传输起始地址</td>
</tr>
<tr>
<td>New DMA Source, High(HDMA1)</td>
<td>0xff51</td>
<td>DMA 传输起始地址的高位, CGB 模式专用</td>
</tr>
<tr>
<td>New DMA Source, Low(HDMA2)</td>
<td>0xff52</td>
<td>DMA 传输起始地址的低位, CGB 模式专用</td>
</tr>
<tr>
<td>New DMA Destination, High(HDMA3)</td>
<td>0xff53</td>
<td>DMA 传输目的地址的高位, CGB 模式专用</td>
</tr>
<tr>
<td>New DMA Destination, Low(HDMA4)</td>
<td>0xff54</td>
<td>DMA 传输目的地址的低位, CGB 模式专用</td>
</tr>
<tr>
<td>New DMA Length/Mode/Start(HDMA5)</td>
<td>0xff55</td>
<td>用于启动从 ROM 或 RAM 到 VRAM 的 DMA 传输</td>
</tr>
<tr>
<td>VRAM Bank(VBK)</td>
<td>0xff4f</td>
<td>VRAM Bank Number</td>
</tr>
</tbody>
</table>
<h1 id="lcdc">LCDC</h1>
<p>LCDC 是主要的 LCD 控制寄存器. 它控制画面上的对象是否显示以及如何显示.</p>
<blockquote>
<p>LCD 液晶显示器(英语: liquid-crystal display)为平面薄型的显示设备, 由一定数量的彩色或黑白像素组成, 放置于光源或者反面前方. 液晶显示器功耗低, 因此备受工程师青睐, 适用于使用电池的电子设备. 它的主要原理是以电流刺激液晶分子产生点, 线, 面配合背部灯管构成画面.
全称: Liquid Crystal Display
简称: LCD
组成: 一定数量的彩色或黑白像素
特点: 低功耗</p>
<p>摘自: https://zh.wikipedia.org/wiki/液晶显示器</p>
</blockquote>
<table>
<thead>
<tr>
<th>位</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bit 7</td>
<td>LCD Display Enable</td>
<td>控制 LCD 是否亮起</td>
</tr>
<tr>
<td>Bit 6</td>
<td>Window Tile Map Display Select</td>
<td>选择 Window Tile Map. 当它为 0 时, Tile Map 起始地址为 0x9800, 否则 0x9C00</td>
</tr>
<tr>
<td>Bit 5</td>
<td>Window Display Enable</td>
<td>控制是否显示窗口</td>
</tr>
<tr>
<td>Bit 4</td>
<td>BG &amp; Window Tile Data Select</td>
<td>该位控制 BG 和 Window 用于寻找 Tile 时的寻址模式</td>
</tr>
<tr>
<td>Bit 3</td>
<td>BG Tile Map Display Select</td>
<td>选择 BG Tile Map. 当它为 0 时, Tile Map 起始地址使用 0x9800, 否则 0x9C00</td>
</tr>
<tr>
<td>Bit 2</td>
<td>OBJ Size</td>
<td>控制 Sprite 的大小. Sprite 大小可以为一个 Tile 或 2 个竖直排列的 Tile</td>
</tr>
<tr>
<td>Bit 1</td>
<td>OBJ Display Enable</td>
<td>是否显示 Sprite</td>
</tr>
<tr>
<td>Bit 0</td>
<td>BG/Window Display/Priority</td>
<td>控制 Sprite 的优先级. 如果设置, Sprite 将始终显示在 BG 之上</td>
</tr>
</tbody>
</table>
<p>Bit 0 控制 Sprite 相对于 BG 的优先级. 一个例子是游戏人物可以被游戏背景所遮掩(例如当游戏人物进入草丛时), 下面的截图展示了这一现象. 它的优势在于开发者无需专门为这种遮掩做额外的画面.</p>
<p><img alt="img" src="/img/gameboy/video/gpu/priority.png" /></p>
<p><strong>代码实现</strong></p>
<pre><code class="rs">// LCDC is the main LCD Control register. Its bits toggle what elements are displayed on the screen, and how.
pub struct Lcdc {
    data: u8,
}

#[rustfmt::skip]
impl Lcdc {
    pub fn power_up() -&gt; Self {
        Self { data: 0b0100_1000 }
    }

    // LCDC.7 - LCD Display Enable
    // This bit controls whether the LCD is on and the PPU is active. Setting it to 0 turns both off, which grants
    // immediate and full access to VRAM, OAM, etc.
    fn bit7(&amp;self) -&gt; bool { self.data &amp; 0b1000_0000 != 0x00 }

    // LCDC.6 - Window Tile Map Display Select
    // This bit controls which background map the Window uses for rendering. When it's reset, the $9800 tilemap is used,
    // otherwise it's the $9C00 one.
    fn bit6(&amp;self) -&gt; bool { self.data &amp; 0b0100_0000 != 0x00 }

    // LCDC.5 - Window Display Enable
    // This bit controls whether the window shall be displayed or not. (TODO : what happens when toggling this
    // mid-scanline ?) This bit is overridden on DMG by bit 0 if that bit is reset.
    // Note that on CGB models, setting this bit to 0 then back to 1 mid-frame may cause the second write to be ignored.
    fn bit5(&amp;self) -&gt; bool { self.data &amp; 0b0010_0000 != 0x00 }

    // LCDC.4 - BG &amp; Window Tile Data Select
    // This bit controls which addressing mode the BG and Window use to pick tiles.
    // Sprites aren't affected by this, and will always use $8000 addressing mode.
    fn bit4(&amp;self) -&gt; bool { self.data &amp; 0b0001_0000 != 0x00 }

    // LCDC.3 - BG Tile Map Display Select
    // This bit works similarly to bit 6: if the bit is reset, the BG uses tilemap $9800, otherwise tilemap $9C00.
    fn bit3(&amp;self) -&gt; bool { self.data &amp; 0b0000_1000 != 0x00 }

    // LCDC.2 - OBJ Size
    // This bit controls the sprite size (1 tile or 2 stacked vertically).
    // Be cautious when changing this mid-frame from 8x8 to 8x16 : &quot;remnants&quot; of the sprites intended for 8x8 could
    // &quot;leak&quot; into the 8x16 zone and cause artifacts.
    fn bit2(&amp;self) -&gt; bool { self.data &amp; 0b0000_0100 != 0x00 }

    // LCDC.1 - OBJ Display Enable
    // This bit toggles whether sprites are displayed or not.
    // This can be toggled mid-frame, for example to avoid sprites being displayed on top of a status bar or text box.
    // (Note: toggling mid-scanline might have funky results on DMG? Investigation needed.)
    fn bit1(&amp;self) -&gt; bool { self.data &amp; 0b0000_0010 != 0x00 }


    // LCDC.0 - BG/Window Display/Priority
    // LCDC.0 has different meanings depending on Gameboy type and Mode:
    // Monochrome Gameboy, SGB and CGB in Non-CGB Mode: BG Display
    // When Bit 0 is cleared, both background and window become blank (white), and the Window Display Bit is ignored in
    // that case. Only Sprites may still be displayed (if enabled in Bit 1).
    // CGB in CGB Mode: BG and Window Master Priority
    // When Bit 0 is cleared, the background and window lose their priority - the sprites will be always displayed on
    // top of background and window, independently of the priority flags in OAM and BG Map attributes.
    fn bit0(&amp;self) -&gt; bool { self.data &amp; 0b0000_0001 != 0x00 }
}
</code></pre>

<h1 id="lcd-status-register">LCD Status Register</h1>
<p>LCD Status Register 寄存器控制 LCD 当前的显示状态.</p>
<table>
<thead>
<tr>
<th>位</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bit 6</td>
<td>LYC=LY Coincidence Interrupt</td>
<td>当 LYC 与 LY 相等且该位为 1 时, 触发中断</td>
</tr>
<tr>
<td>Bit 5</td>
<td>Mode 2 OAM Interrupt</td>
<td>模式 2 OAM 中断开关</td>
</tr>
<tr>
<td>Bit 4</td>
<td>Mode 1 V-Blank Interrupt</td>
<td>模式 1 V-Blank 中断开关</td>
</tr>
<tr>
<td>Bit 3</td>
<td>Mode 0 H-Blank Interrupt</td>
<td>模式 0 H-Blank 中断开关</td>
</tr>
<tr>
<td>Bit 2</td>
<td>Coincidence Flag</td>
<td>当前 LY 是否与 LYC 相等</td>
</tr>
<tr>
<td>Bit 1-0</td>
<td>Mode Flag</td>
<td>当前 GPU 所处的周期</td>
</tr>
</tbody>
</table>
<p>Bit 1 和 Bit 0 共同负责存储 LCD 控制器的当前状态/模式. 模式有以下四种可选值:</p>
<ul>
<li>Mode 0: During H-Blank</li>
<li>Mode 1: During V-Blank</li>
<li>Mode 2: During Searching OAM</li>
<li>Mode 3: During Transferring Data to LCD Driver</li>
</ul>
<p>LCD 控制器以 4.194 MHz 的时钟工作. 游戏的一帧可表达为 154 条 scanline, 70224 像素点或 16.74 ms. 在 scanline 0 到 143 上, LCD 控制器每 456 点在模式2, 3 和 0 上循环一次. Scanline 144 至 153 为模式 1.</p>
<p>启用画面显示后, 以下是一个典型的 Mode 切换流程:</p>
<pre><code class="no-highlight">Mode 2  2_____2_____2_____2_____2_____2___________________2____
Mode 3  _33____33____33____33____33____33__________________3___
Mode 0  ___000___000___000___000___000___000________________000
Mode 1  ____________________________________11111111111111_____
</code></pre>

<p>当 LCD 控制器正在读取视频存储器的特定部分时, CPU 将无法访问某些特定存储器.</p>
<ul>
<li>在 Mode 2 和 3 下，CPU 无法访问 OAM(0xfe00-0xfe9f)</li>
<li>在 Mode 3 期间, CPU 无法访问 VRAM 或 CGB 调色板数据(0xff69, 0xff6b)</li>
</ul>
<p><strong>代码实现</strong></p>
<pre><code class="rs">// LCD Status Register.
pub struct Stat {
    // Bit 6 - LYC=LY Coincidence Interrupt (1=Enable) (Read/Write)
    enable_ly_interrupt: bool,
    // Bit 5 - Mode 2 OAM Interrupt         (1=Enable) (Read/Write)
    enable_m2_interrupt: bool,
    // Bit 4 - Mode 1 V-Blank Interrupt     (1=Enable) (Read/Write)
    enable_m1_interrupt: bool,
    // Bit 3 - Mode 0 H-Blank Interrupt     (1=Enable) (Read/Write)
    enable_m0_interrupt: bool,
    // Bit 1-0 - Mode Flag       (Mode 0-3, see below) (Read Only)
    //    0: During H-Blank
    //    1: During V-Blank
    //    2: During Searching OAM
    //    3: During Transferring Data to LCD Driver
    mode: u8,
}

impl Stat {
    pub fn power_up() -&gt; Self {
        Self {
            enable_ly_interrupt: false,
            enable_m2_interrupt: false,
            enable_m1_interrupt: false,
            enable_m0_interrupt: false,
            mode: 0x00,
        }
    }
}
</code></pre>

<h1 id="lcd-interrupts">LCD Interrupts</h1>
<p>LCD 可以产生两种不同类型的中断, 它们分别是 INT 40 和 INT 48.</p>
<ul>
<li>INT 40 - V-Blank Interrupt: V-Blank 中断每秒可固定产生约 60 次, 该中断发生在 V-Blank 期间(LY == 144 时). 在此期间, Game Boy 硬件不会使用 VRAM, 因此 CPU 可以自由访问它. 该时间段持续大约 1.1 毫秒.</li>
<li>INT 48 - LCDC Status Interrupt: 如 STAT 寄存器(0xff40)所述, 有多种原因可以导致此中断发生. 一个非常普遍的原因是向用户指示 Game Boy 的 GPU 硬件何时将重画给定的 LCD scanline. 这对于动态控制 SCX/SCY 寄存器(0xff43/0xff42)来执行特殊的视频效果很有用.</li>
</ul>
<h1 id="scroll-y-scroll-x">Scroll Y, Scroll X</h1>
<p>SCY(Scroll Y), SCX(Scroll X) 指定要显示在 LCD 上的图像在 256 * 256 BG 中的位置(左上角). 当绘图大小超过 BG 地图区域的右下边界时, 视频控制器自动回绕到 BG 地图中的左上位置. 在上一小节《图像显示系统简介》有详细介绍.</p>
<h1 id="lcdc-y-coordinate">LCDC Y-Coordinate</h1>
<p>LY(LCDC Y-Coordinate) 表示当前正在绘制 LCD 屏幕的第几行. LY 可以取 0 到 153 之间的任何值, 其中 144 和 153 之间的值表示正处于 V-Blank 周期.</p>
<h1 id="lyc">LYC</h1>
<p>LYC(LY Compare) 是一个特殊的值, Game Boy 永久地比较 LYC 和 LY 寄存器的值. 当两个值相同时, LCD Status Register 中的 Coincidence Flag 被置位, 并且请求 STAT 中断(如果允许的话).</p>
<h1 id="window-y-window-x">Window Y, Window X</h1>
<p>用于表示指定 Window 区域的左上位置. Window 是一个可以在正常背景上方显示的备用背景区域, Sprite 可能仍然显示在窗口的上方或后方, 就像正常的 BG 一样. 一个比较形象的例子是, 当游戏任务在大地图上与 NPC 交谈时, 对话框通常就是一个窗口. Window 在上一小节《图像显示系统简介》有详细介绍.</p>
<p>当位置设置在范围 0 &lt;= WX &lt;= 166, 0 &lt;= WY &lt;= 143 时, 窗口变为可见(如果 LCDC 寄存器允许显示窗口的话). 注意: WX = 7, WY = 0 的位置将使窗口位于 LCD 的左上角(完全覆盖正常背景).</p>
<h1 id="bgp">BGP</h1>
<p>BGP(BG Palette Data) 为 BG 和 Window Tile 的颜色编号指定对应灰度. 只在非 CGB 模式(非彩色 Game Boy 或彩色 Game Boy 以黑白模式运行)下有效.</p>
<table>
<thead>
<tr>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bit 7-6</td>
<td>编号为 3 的灰度(黑)</td>
</tr>
<tr>
<td>Bit 5-4</td>
<td>编号为 2 的灰度(深灰)</td>
</tr>
<tr>
<td>Bit 3-2</td>
<td>编号为 1 的灰度(浅灰)</td>
</tr>
<tr>
<td>Bit 1-0</td>
<td>编号为 0 的灰度(白)</td>
</tr>
</tbody>
</table>
<p>一种常见的灰度值选择是</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>颜色</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>White</td>
</tr>
<tr>
<td>1</td>
<td>Light gray</td>
</tr>
<tr>
<td>2</td>
<td>Dark gray</td>
</tr>
<tr>
<td>3</td>
<td>Black</td>
</tr>
</tbody>
</table>
<p>对于 CGB 来说, Palettes 数据取自 CGB Palettes Memory, 后文将会介绍.</p>
<h1 id="obp0">OBP0</h1>
<p>OBP0(Object Palette 0 Data) 为 Sprite Palettes 0 指定灰度. 它与 BGP(0xff47)完全相同, 只是因为 Sprite 的颜色数据 00 是透明的, 所以不使用低两位.</p>
<h1 id="obp1">OBP1</h1>
<p>OBP1(Object Palette 1 Data) 为 Sprite Palettes 1 指定灰度. 它与 BGP(0xff47)完全相同, 只是因为 Sprite 的颜色数据 00 是透明的, 所以不使用低两位.</p>
<h1 id="bcpsbgpi">BCPS/BGPI</h1>
<p>BGPI(Background Palette Index) 用于寻址 BG Palettes 存储器中的一个字节. 该存储器中的每两个字节定义一个颜色值. 前 8 个字节定义 Palette 0(BGP0) 的 Color 0-3, 以此类推 BGP 1-7.</p>
<table>
<thead>
<tr>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bit 0-5</td>
<td>索引(00-3f)</td>
</tr>
<tr>
<td>Bit 7</td>
<td>自增开关(0=禁用, 1=每次写操作后自增)</td>
</tr>
</tbody>
</table>
<p>可以通过寄存器 0xff69 从指定的索引地址读取/写入数据. 如果设置了自增开关, 每次写数据到 0xff69 后索引(Bit 0-5)会自动递增. 当从 0xff69 读取时, 不会自动递增. 因此在这种情况下必须手动递增索引.</p>
<p>可以在非 V-Blank 和 H-Blank 期间访问该寄存器.</p>
<p><strong>代码实现</strong></p>
<pre><code class="rs">// This register is used to address a byte in the CGBs Background Palette Memory. Each two byte in that memory define a
// color value. The first 8 bytes define Color 0-3 of Palette 0 (BGP0), and so on for BGP1-7.
//  Bit 0-5   Index (00-3F)
//  Bit 7     Auto Increment  (0=Disabled, 1=Increment after Writing)
// Data can be read/written to/from the specified index address through Register FF69. When the Auto Increment bit is
// set then the index is automatically incremented after each &lt;write&gt; to FF69. Auto Increment has no effect when
// &lt;reading&gt; from FF69, so the index must be manually incremented in that case. Writing to FF69 during rendering still
// causes auto-increment to occur.
// Unlike the following, this register can be accessed outside V-Blank and H-Blank.
struct Bgpi {
    i: u8,
    auto_increment: bool,
}

impl Bgpi {
    fn power_up() -&gt; Self {
        Self {
            i: 0x00,
            auto_increment: false,
        }
    }

    fn get(&amp;self) -&gt; u8 {
        let a = if self.auto_increment { 0x80 } else { 0x00 };
        a | self.i
    }

    fn set(&amp;mut self, v: u8) {
        self.auto_increment = v &amp; 0x80 != 0x00;
        self.i = v &amp; 0x3f;
    }
}
</code></pre>

<h1 id="bcpdbgpd">BCPD/BGPD</h1>
<p>BGPD(Background Palette Data) 寄存器允许读取或写入通过寄存器 0xff68 寻址的 BG Palettes 的数据. 每种颜色由两个字节定义.</p>
<table>
<thead>
<tr>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bit 0-4</td>
<td>红 (00-1f)</td>
</tr>
<tr>
<td>Bit 5-9</td>
<td>绿 (00-1f)</td>
</tr>
<tr>
<td>Bit 10-14</td>
<td>蓝 (00-1f)</td>
</tr>
</tbody>
</table>
<p>与 VRAM 极为相似, 在从 LCD 控制器读取调色板内存期间, 无法读取/写入调色板内存中的数据(即当 STAT 寄存器指示模式 3 时).</p>
<h1 id="ocpsobpi">OCPS/OBPI</h1>
<p>OBPI(Sprite Palette Index) 寄存器与 BGPI 寄存器描述的几乎完全一样, 但区别在于其初始化 Sprite Palettes OBP 0-7.</p>
<h1 id="ocpdobpd">OCPD/OBPD</h1>
<p>OBPD(Sprite Palette Data) 寄存器与 BGPD 寄存器描述的几乎完全一样, 但区别在于其初始化 Sprite Palettes OBP 0-7. 请注意, 虽然可以为每个 OBP Palettes 定义四种颜色, 但是只能显示每个 Sprite Palette 的 Color 1-3, 而 Color 0 始终是透明的, 并且可以初始化为无关值或从不初始化.</p>
<p>注意：所有 Sprite 的颜色都不会由引导 ROM 初始化.</p>
<h1 id="rgb">仿真器开发过程中的 RGB 色彩转换</h1>
<p>与现在常用的 8 位 RGB 色彩模式不同, Game Boy 只使用 4 位表示一种颜色通道, 每种色彩通道的范围使 0x00 到 0x1f. 在 PC 上显示图像颜色时, 需要进行一次对比拉伸, 即拉伸到 0x00 到 0xff 范围. 但是要注意这种转换并不是线性的, 目前尝试下来比较合理的拉伸算法如下所示:</p>
<pre><code class="rs">fn get_rgb(r: u8, g: u8, b: u8) -&gt; (u8, u8, u8) {
    let r = u32::from(r);
    let g = u32::from(g);
    let b = u32::from(b);

    let lr = ((r * 13 + g * 2 + b) &gt;&gt; 1) as u8;
    let lg = ((g * 3 + b) &lt;&lt; 1) as u8;
    let lb = ((r * 3 + g * 2 + b * 11) &gt;&gt; 1) as u8;

    return (lr, lg, lb);
}
</code></pre>

<p>这个算法并非包含什么数学证明在里面, 只是在不断尝试各种转换方法后发现其对人眼比较友好. 与之类似的在彩色图像转灰度图上, 有一个很著名的心理学公式:</p>
<pre><code class="no-highlight">Gray = R*0.299 + G*0.587 + B*0.114
</code></pre>

<p>该公式同样是人为挑选出来的.</p>
<h1 id="dma">DMA</h1>
<p>写入 DMA(DMA Transfer and Start Address) 寄存器会启动从 ROM 或 RAM 到 OAM 存储器的 DMA 传输(传输的数据是 Sprite 属性表). 写入的值会除以 0x0100 后作为数据源地址的高两位地址, 数据源与数据目的地如下所示:</p>
<pre><code class="no-highlight">Source:      XX00-XX9F
Destination: FE00-FE9F
</code></pre>

<p>传输需要 160 个机器周期, 约 152 微秒. 在此期间, CPU 只能访问 HRAM 内存区间(0xff80-0xfffe).</p>
<h1 id="hdma1-hdma2">HDMA1, HDMA2</h1>
<p>两个寄存器共同组成了 New DMA Source. New DMA Source 的行为同 DMA 类似, 这两个寄存器指定传输源的地址, 通常, 这应该是 ROM, SRAM 或 WRAM 中的一个地址, 因此在 0x0000-0x7ff0 或 0xa000-0xdff0 范围内.</p>
<p>该地址的低 4 位将被忽略并视为 0.</p>
<h1 id="hdma3-hdma4">HDMA3, HDMA4</h1>
<p>两个寄存器共同组成了 New DMA Destination. New DMA Destination 只有中间的第 12-4 位有效, 且低 4 位被忽略视为 0. 因此 New DMA Destination 的范围是 0x8000-0x9ff0.</p>
<h1 id="hdma5">HDMA5</h1>
<p>HDMA5(New DMA Length/Mode/Start) 用于启动从 ROM 或 RAM 到 VRAM 的 DMA 传输. 源起始地址为 New DMA Source, 目标地址为 New DMA Destination.</p>
<p>向该寄存器写入数据即可开始传输, 其低 7 位指定传输长度. 传输长度与低 7 位数据的关系为 <code>Length = 0x10 * (X + 1)</code>, 因此 Length 的范围为 0x0010 到 0x0800. 该寄存器最高位表示传输模式:</p>
<ul>
<li>Bit7=0 时, 使用 General Purpose DMA. 使用此传输方法时, 将立即传输所有数据. 程序的执行将暂停, 直到传输完成. 请注意, 即使 LCD 控制器当前正在访问 VRAM, DMA 也会尝试复制数据. 因此, 仅当显示器被禁用时, 或者在 V-Blank 期间, 或者(对于相当短的块长度)在 H-Blank 期间, 才应使用通用 DMA. 传输完成后程序的执行继续, 并向 0xff55 写入值 0xff.</li>
<li>Bit7=1 时, 使用 H-Blank DMA. H-Blank DMA 在每个 H-Blank 期间传输 0x10 字节的数据(即 LY = 0-143 时). 在 V-Blank 期间不会传输数据(即 LY = 144-153) 时. 寄存器 0xff55 的低 7 位存储剩余待传输数据的大小(注意需要使用上述公式进行转换). 值 0xff 表示当前传输已完成. 通过将 0 写入 0xff55 的最高位, 也可以终止当前的 H-Blank DMA 传输.</li>
</ul>
<h1 id="dma_1">DMA 代码实现</h1>
<pre><code class="rs">pub struct Hdma {
    // These two registers specify the address at which the transfer will read data from. Normally, this should be
    // either in ROM, SRAM or WRAM, thus either in range 0000-7FF0 or A000-DFF0. [Note : this has yet to be tested on
    // Echo RAM, OAM, FEXX, IO and HRAM]. Trying to specify a source address in VRAM will cause garbage to be copied.
    // The four lower bits of this address will be ignored and treated as 0.
    pub src: u16,
    // These two registers specify the address within 8000-9FF0 to which the data will be copied. Only bits 12-4 are
    // respected; others are ignored. The four lower bits of this address will be ignored and treated as 0.
    pub dst: u16,
    pub active: bool,
    pub mode: HdmaMode,
    pub remain: u8,
}

impl Gpu {
    fn run_dma(&amp;mut self) -&gt; u32 {
        if !self.hdma.active {
            return 0;
        }
        match self.hdma.mode {
            HdmaMode::Gdma =&gt; {
                let len = u32::from(self.hdma.remain) + 1;
                for _ in 0..len {
                    self.run_dma_hrampart();
                }
                self.hdma.active = false;
                len * 8
            }
            HdmaMode::Hdma =&gt; {
                if !self.gpu.h_blank {
                    return 0;
                }
                self.run_dma_hrampart();
                if self.hdma.remain == 0x7f {
                    self.hdma.active = false;
                }
                8
            }
        }
    }

    fn run_dma_hrampart(&amp;mut self) {
        let mmu_src = self.hdma.src;
        for i in 0..0x10 {
            let b: u8 = self.get(mmu_src + i);
            self.gpu.set(self.hdma.dst + i, b);
        }
        self.hdma.src += 0x10;
        self.hdma.dst += 0x10;
        if self.hdma.remain == 0 {
            self.hdma.remain = 0x7f;
        } else {
            self.hdma.remain -= 1;
        }
    }
}
</code></pre>

<h1 id="vram-tile-data">VRAM Tile Data</h1>
<p>Tile 数据存储在 VRAM 中的地址 0x8000-0x97ff 区间内, 其中一个 Tile 为 16 字节大, 该区域总共定义了 384 个 Tile 的数据. 在 CGB 模式下, 由于有两个 VRAM 库, 因此它加倍至 768 个 Tile.</p>
<p>每个 Tile 的大小为 8x8 像素, 颜色深度为 4 种颜色/灰色阴影. Tile 可以用于显示为 BG 或 Window 贴图的一部分, 或显示为 Sprite. 请注意, Sprite 不使用颜色 0, 颜色 0 在 Sprite 中是透明的.</p>
<p>0x8000-0x97ff 内存区间被分为 3 个明显的功能不同的块(Block), 每个块包含 128 个 Tile:</p>
<ul>
<li>Block 0 is 0x8000-0x87ff</li>
<li>Block 1 is 0x8800-0x8fff</li>
<li>Block 2 is 0x9000-0x97ff</li>
</ul>
<p>观察每个区间的范围, 可以发现每个 Tile 都可以被一个 Block Index 和一个 8 位的 Tile Index 进行索引, 不过不同的区间索引方式可能不同: "8000 寻址"方法采用 0x8000 作为其基础地址, 并将 8 位 Tile Index 作为无符号整数与其相加(这意味着 Tile 0-127 在 Block 0 中, Tile 128-255 在 Block 1中); "8800 寻址"方法采用 0x9000 作为其基础地址, 并将 8 位 Tile Index 作为有符号整数与其相加. 换句话说, "8000 寻址"从 Block 0 获取 Tile 0-127, 从 Block 1 获取 Tile 128-255, 而"8800 寻址"从 Block 2 获取 Tile 0-127, 从 Block 1 获取 Tile 128-255. 可以注意到 Block 1 由两种寻址方法共享.</p>
<p>Sprite 总是使用 8000 寻址, 但 BG 和 Window 可以使用任何一种模式, 具体由 LCDC(LCD Control Register) 的 Bit 4 控制.</p>
<p>每个 Tile 占用 16 个字节, 其中每个 2 个字节代表一行:</p>
<pre><code class="no-highlight">Byte 0-1  First Line (Upper 8 pixels)
Byte 2-3  Next Line
etc.
</code></pre>

<p>Tile 中的每个像素的低位保持在一个字节中, 而高位在另一个字节中. 下面的结构表示 Tile 中的 8 个像素, 第一个像素是 01 = 深灰, 第二个像素是 10 = 浅灰, 并以此类推.</p>
<pre><code class="no-highlight">[0x803e] | 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | = 0x4e
[0x803f] | 1 | 0 | 0 | 0 | 1 | 0 | 1 | 1 | = 0x8d
</code></pre>

<p>因此, 每个像素的色数范围为 0-3. 根据当前调色板, 颜色编号被转换为真实颜色(或灰色阴影).</p>
<h1 id="vram-background-maps">VRAM Background Maps</h1>
<p>Game Boy 在地址 0x9800-0x9bff 和 0x9c00-0x9fff 的 VRAM 中包含两个大小为 32x32 的 Tile 映射. 每个映射关系都可用于显示 BG 或 Window 的背景.</p>
<p>VRAM 中包含一个被称之为 Background Tile Map 的一个区域, 其中包含要显示的 Tile 数量. 它组织为 32 行, 每行 32 个字节. 每个字节包含许多要显示的图块. 可以使用两种寻址模式进行寻址(如上所述). 由于一个背景图块的大小为 8x8 像素, 因此 BG 贴图可以容纳 256x256 像素的图片, 并且该图片的其中 160x144 像素的区域可以显示在 LCD 屏幕上.</p>
<p>在 CGB 模式下, VRAM Bank 1 中存储了额外的一个 32x32 字节的映射(每个字节定义了 VRAM Bank 0 中相应的 Tile 的属性). 举个简单的例子: 1:9800 定义了存储于 0:9800 的 Tile 的属性.</p>
<table>
<thead>
<tr>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bit 0-2</td>
<td>背景调色板编号 (BGP0-7)</td>
</tr>
<tr>
<td>Bit 3</td>
<td>Tile VRAM 的 Bank number (0=Bank 0, 1=Bank 1)</td>
</tr>
<tr>
<td>Bit 4</td>
<td>未使用</td>
</tr>
<tr>
<td>Bit 5</td>
<td>是否水平翻转 (0=Normal, 1=Mirror horizontally)</td>
</tr>
<tr>
<td>Bit 6</td>
<td>是否垂直翻转 (0=Normal, 1=Mirror vertically)</td>
</tr>
<tr>
<td>Bit 7</td>
<td>BG 相对于 Sprite 的显示优先级 (0=Use OAM priority bit, 1=BG Priority)</td>
</tr>
</tbody>
</table>
<p>当 Bit 7 置位时, 相应的 BG Tile 将优先于所有 Sprite(无论 OAM 存储器中的优先级位如何). LCDC 寄存器的位 0 还有一个主优先级标志, 当清零时, 它会覆盖所有其他优先级位.</p>
<p>SCY 和 SCX 寄存器可用于滚动 BG, 其允许在总 256x256 像素 BG 图中选择可见的 160x144 像素区域的原点.</p>
<p>除了 BG, 还有一个覆盖 BG 的 Windos. Windos 不可滚动, 也就是说, 它始终从左上角开始显示. 可以通过 WX 和 WY 寄存器调整屏幕上窗口的位置. 注意窗口左上角的屏幕坐标为 (WX-7, WY). 窗口与 BG 共享相同的 Tile 数据表. 背景和窗口都可以通过 LCDC 寄存器中的特定位单独禁用或启用.</p>
<h1 id="vbk">VBK</h1>
<p>由于 CGB 拥有两倍的 VRAM, 因此需要一个 Bank Number 用于指定当前的 VRAM Bank. 可以向 VBK(VRAM Banks) 写入以更改 VRAM Bank, 只有位 0 有意义, 所有其他位都被忽略.</p>
<p>VRAM Bank 1 像 VRAM Bank 0 一样被分割为不同区域. 0x8000-0x97ff 还存储了 Tile(就像在 Bank 0 中一样), 其可以与 Bank 0 Tile 相同的方式访问. 0x9800-0x9fff 包含相应 Tile Maps 的属性.</p>
<p>从该寄存器读取将返回位 0 中当前加载的 VRAM 存储区的编号, 并且所有其他位将设置为 1.</p>
<h1 id="vram-sprite-attribute-table-oam">VRAM Sprite Attribute Table (OAM)</h1>
<p>Game Boy 视频控制器最多可以显示 40 个 8x8 或 8x16 像素的 Sprite. 由于硬件的限制, 每条 Scanline 只能显示 10 个 Sprite. Sprite Tile 与 BG Tile 数据格式相同, 但它们取自位于 0x8000-0x8fff 的 Sprite Pattern Table. OAM 中的一个元素占用 4 个字节大小.</p>
<p><strong>Byte0 - Y Position</strong></p>
<p>指定屏幕上的 Sprite 的垂直位置(减去 16). 屏幕外的值(例如, Y = 0 或 Y &gt;= 160)不会显示 Sprite.</p>
<p><strong>Byte1 - X Position</strong></p>
<p>指定屏幕上的 Sprite 的水平位置(减去 8). 屏幕外的值(例如, X = 0 或 X &gt;= 168)不会显示 Sprite.</p>
<p><strong>Byte2 - Tile/Pattern Number</strong></p>
<p>指定 Sprite 的编号(0x00-0xff). 此值从内存中选择位于 0x8000-0x8fff 的 Tile. 在 CGB 模式下, Tile 可以位于 VRAM Bank 0 或 1 中, 具体取决于后续字节的位 3. 在 8x16 模式下, Tile 编号的低位被忽略, 例如: 上部 8x8 Tile 编号是 N 的话, 那下半部分 Tile 编号就是 N + 1.</p>
<p><strong>Byte3 - Attributes/Flags:</strong></p>
<table>
<thead>
<tr>
<th>位</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bit7</td>
<td>OBJ-to-BG Priority</td>
<td>显示优先级 (0=OBJ 优先显示 BG, 1=OBJ 滞后 BG color 1-3 )</td>
</tr>
<tr>
<td>Bit6</td>
<td>Y flip</td>
<td>是否翻转 Y 轴</td>
</tr>
<tr>
<td>Bit5</td>
<td>X flip</td>
<td>是否翻转 X 轴</td>
</tr>
<tr>
<td>Bit4</td>
<td>Palette number</td>
<td>非 CGB 模式下有效 (0=OBP0, 1=OBP1)</td>
</tr>
<tr>
<td>Bit3</td>
<td>Tile VRAM-Bank</td>
<td>CGB 模式下有效 (0=Bank 0, 1=Bank 1)</td>
</tr>
<tr>
<td>Bit2-0</td>
<td>Palette number</td>
<td>CGB 模式下有效 (OBP0-7)</td>
</tr>
</tbody>
</table>
<p><strong>代码实现</strong></p>
<pre><code class="rs">// Bit7   OBJ-to-BG Priority (0=OBJ Above BG, 1=OBJ Behind BG color 1-3)
//     (Used for both BG and Window. BG color 0 is always behind OBJ)
// Bit6   Y flip          (0=Normal, 1=Vertically mirrored)
// Bit5   X flip          (0=Normal, 1=Horizontally mirrored)
// Bit4   Palette number  **Non CGB Mode Only** (0=OBP0, 1=OBP1)
// Bit3   Tile VRAM-Bank  **CGB Mode Only**     (0=Bank 0, 1=Bank 1)
// Bit2-0 Palette number  **CGB Mode Only**     (OBP0-7)
struct Attr {
    priority: bool,
    yflip: bool,
    xflip: bool,
    palette_number_0: usize,
    bank: bool,
    palette_number_1: usize,
}

impl From&lt;u8&gt; for Attr {
    fn from(u: u8) -&gt; Self {
        Self {
            priority: u &amp; (1 &lt;&lt; 7) != 0,
            yflip: u &amp; (1 &lt;&lt; 6) != 0,
            xflip: u &amp; (1 &lt;&lt; 5) != 0,
            palette_number_0: u as usize &amp; (1 &lt;&lt; 4),
            bank: u &amp; (1 &lt;&lt; 3) != 0,
            palette_number_1: u as usize &amp; 0x07,
        }
    }
}
</code></pre>

<p><strong>Sprite 优先级</strong></p>
<p>在每个 Scanline 的 OAM 扫描期间, LCD 控制器将 LY 与每个 Sprite 的 Y 进行比较, 以找到该行中最先出现在 OAM 中的 10 个 Sprite. GPU 将舍弃其余的 Sprite, 因为其只允许在任何一行上显示 10 个 Sprite. 超过此限制时, 将不会显示后续在 OAM 中出现的 Sprite. 为了防止未使用的 Sprite 影响屏幕上的 Sprite, 游戏开发者通常将其 Y 坐标设置为 Y = 0 或 Y &gt;= 160(144 + 16)(注意: 如果将 Sprite 大小设置为 8x8 像素, Y &lt;= 8 也可以使用). 或者将一个 Srpite 上的 X 坐标设置为 X = 0 或 X &gt;= 168(160 + 8)也可将其隐藏, 但仍会影响共享同一行的其他 Sprite.</p>
<p>当这 10 个 Sprite 坐标重叠时, 优先级最高的将出现在所有其他 Sprite 之上, 依此类推. 在 CGB 模式下, OAM 中的第一个 Sprite(0xfe00- 0xfe03)具有最高优先级. 在非 CGB 模式下, X 坐标越小, 优先级越高, 若 X 坐标相同, 则优先级退化至 CGB 模式下.</p>
<p>Sprite 之间的优先级计算将忽略 OBJ 到 BG 的优先级(LCDC 寄存器的位 0), 其仅将任意给定点上优先级最高的非透明色彩的子画面像素与 BG 进行比较. 因此, 如果具有较高优先级(基于 OAM 索引)但启用了 OBJ-to-BG 优先级的精灵与具有较低优先级和非透明色彩像素的 Sprite 重叠, 则显示背景像素, 而不考虑优先级较低的 Sprite 的 OBJ-to-BG 优先级.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../code/" class="btn btn-neutral float-right" title="GB-视频-代码实现">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../system/" class="btn btn-neutral" title="GB-视频-图像显示系统"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../system/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../code/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    
    <script>var base_url = '../../../..';</script>
    <script src="../../../../js/theme.js" defer></script>
      <script src="../../../../js/accu.js" defer></script>
      <script src="../../../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>


</body>
</html>
