<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Mohanson">
  <link rel="canonical" href="http://accu.cc/content/gameboy/cpu/lr35902_standard/">
  <link rel="shortcut icon" href="../../../../img/favicon.ico">
  <title>GB-CPU-LR35902标准指令集 - Mohanson</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../../../css/theme.css" />
  <link rel="stylesheet" href="../../../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  <link href="../../../../css/accu.css" rel="stylesheet" />
    
  
  <script>
    // Current page data
    var mkdocs_page_name = "GB-CPU-LR35902\u6807\u51c6\u6307\u4ee4\u96c6";
    var mkdocs_page_input_path = "content/gameboy/cpu/lr35902_standard.md";
    var mkdocs_page_url = "/content/gameboy/cpu/lr35902_standard/";
  </script>
  
  <script src="../../../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
    <script data-ad-client="ca-pub-5236818090688638" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../../../.." class="icon icon-home"> Mohanson</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../..">主页</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">数字图像处理</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/channel/">数字图像处理-通道</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/mean/">数字图像处理-均值</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/contrast/">数字图像处理-对比增强</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/contrast_tensile/">数字图像处理-对比拉伸</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/bit/">数字图像处理-位图切割</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/histogram_equalization/">数字图像处理-直方图均衡化</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/sub/">数字图像处理-图像减法</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/agwn/">数字图像处理-加性高斯白噪声与去噪</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/spatial_filter/">数字图像处理-空间滤波基础</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/spatial_filter_mean/">数字图像处理-空间滤波-均值滤波</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/spatial_filter_medium/">数字图像处理-空间滤波-中值滤波</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/spatial_filter_sharpening/">数字图像处理-空间滤波-锐化滤波</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/spatial_filter_gaussian_blur/">数字图像处理-空间滤波-高斯滤波</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/frequency_filter/">数字图像处理-频域滤波基础</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/frequency_filter_lpf/">数字图像处理-频域滤波-低通滤波</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/frequency_filter_hpf/">数字图像处理-频域滤波-高通滤波</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/frequency_filter_br_bp/">数字图像处理-频域滤波-带阻和带通滤波</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/noise/">数字图像处理-噪声</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/safe_color/">数字图像处理-安全色</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/macaron_color/">数字图像处理-马卡龙色</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/complementary_and_invert_color/">数字图像处理-补色和反色</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/watermark/">数字图像处理-水印</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/resize_nearst/">数字图像处理-缩放-最近邻插值法</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/resize_nearst_ghost/">数字图像处理-缩放-最近邻插值法的幽灵事件</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/resize_bilinear/">数字图像处理-缩放-双线性算法</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/resize_bicubic/">数字图像处理-缩放-双三次插值法</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/ascii/">数字图像处理-字符画</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/pil_tutorial_overview/">Python-PIL-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/pil_image/">Python-PIL-Image</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/pil_imagechops/">Python-PIL-ImageChops</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/pil_imagecolor/">Python-PIL-ImageColor</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/pil_imagedraw/">Python-PIL-ImageDraw</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/pil_imageenhance/">Python-PIL-ImageEnhance</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../pil/pil_imageops/">Python-PIL-ImageOps</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">自己动手写 Game Boy 仿真器</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../../preface/">GB-前言</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../history/emulator/">GB-虚拟机发展史-硬件仿真器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../history/runtime/">GB-虚拟机发展史-程序虚拟机</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../history/simulator/">GB-虚拟机发展史-软件模拟器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cartridge/about_cartridge/">GB-游戏卡带-漫谈卡带</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cartridge/cartridge_header/">GB-游戏卡带-Header</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cartridge/memory_bank_controller/">GB-游戏卡带-Memory Bank Controller</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cartridge/rom_only/">GB-游戏卡带-ROM only</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cartridge/mbc1/">GB-游戏卡带-MBC1</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cartridge/mbc2/">GB-游戏卡带-MBC2</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cartridge/mbc3/">GB-游戏卡带-MBC3</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cartridge/mbc5/">GB-游戏卡带-MBC5</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../cartridge/others/">GB-游戏卡带-完整代码</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../overview/">GB-CPU-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../alu/">GB-CPU-算术逻辑单元</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../register/">GB-CPU-寄存器与存储系统</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../isa/">GB-CPU-指令与指令集</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../pipeline/">GB-CPU-流水线</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">GB-CPU-LR35902标准指令集</a>
    <ul class="current">
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../lr35902_extension/">GB-CPU-LR35902扩展指令集</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../cycles/">GB-CPU-LR35902时钟周期与频率仿真</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../interrupts/">GB-CPU-LR35902中断</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../mmu/">GB-CPU-内存管理单元与主板</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../video/overview/">GB-视频-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../video/dot_matrix/">GB-视频-点阵图</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../video/show/">GB-视频-显示输出</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../video/crt/">GB-视频-光栅成像原理与概念</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../video/system/">GB-视频-图像显示系统</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../video/gpu/">GB-视频-GPU 寄存器与内存结构</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../video/code/">GB-视频-代码实现</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/overview/">GB-音频-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/sound/">GB-音频-声音的构成</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/cpal/">GB-音频-Rust Cpal 库介绍</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/concept/">GB-音频-音频系统概念简介</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/register/">GB-音频-寄存器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/timer/">GB-音频-512 Hz 时钟信号</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/frame_sequence/">GB-音频-序列发生器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/length_counter/">GB-音频-长度计数器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/vol/">GB-音频-音量包络</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/frequency_sweep/">GB-音频-频率扫描器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/square/">GB-音频-方波通道 1 & 2</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/wave/">GB-音频-可编程波形通道</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/noise/">GB-音频-白噪音通道</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/mixer/">GB-音频-混频器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../audio/play/">GB-音频-在计算机上播放</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../other/joypad/">GB-其他-游戏手柄</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../other/serial/">GB-其他-串行通行接口</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../other/timer/">GB-其他-定时器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../other/init/">GB-其他-硬件初始化工作</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../other/test/">GB-其他-测试</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../foot/">GB-后记</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">算法</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/ga/sga/">遗传算法-简单遗传算法</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/ga/sga_optret/">遗传算法-最优保留策略</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/ga/evolve/">遗传算法-生物进化模拟</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/ga/fooled_nn/">遗传算法-愚弄神经网络</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/dlib/install/">Dlib-安装</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/dlib/face_detect/">Dlib-人脸检测</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/dlib/face_landmark/">Dlib-人脸标注</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/dlib/face_recognition/">Dlib-人脸识别</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/dlib/face_clustering/">Dlib-人脸聚类</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/rc4/overview/">加密算法-RC4-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/rc4/performance_testing/">加密算法-RC4-性能测试</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/game_of_life/overview/">生命游戏</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/sklearn/overview/">sklearn-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/sklearn/liner_model/overview/">sklearn-线性模型-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/sklearn/liner_model/linear_regression/">sklearn-线性模型-普通最小二乘法</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/sklearn/liner_model/ridge/">sklearn-线性模型-岭回归</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/sklearn/liner_model/logistic_regression/">sklearn-线性模型-逻辑回归</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/sklearn/tree/">sklearn-决策树</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/sklearn/bayes/">sklearn-贝叶斯分类器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/sklearn/knn/">sklearn-kNN</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/sklearn/cluster/">sklearn-聚类</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/sklearn/svm/">sklearn-SVM</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/sklearn/manifold/">sklearn-流形学习</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/sklearn/evaluation/">sklearn-评估</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/ml/neural_style_transfer/">机器学习-图像风格转移</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/ml/fasttext/">机器学习-快速文本分类</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/ml/hog/">机器学习-HOG</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/math/huffman/">Math-霍夫曼编码</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/math/variance_and_sd/">Math-方差与标准差</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/math/normal_distribution/">Math-正态分布</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../daze/math/kelly_formula/">Math-凯利公式</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">语言</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/np/split/">Python-np-分割与合并</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/plt/line/">Python-matplotlib-折线图</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/plt/scatter/">Python-matplotlib-散点图</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/plt/bar/">Python-matplotlib-柱状图</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/plt/pie/">Python-matplotlib-饼图</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/f_string/">Python-f-string</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/ctypes/overview/">Python-windows编程-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/ctypes/recycle/">Python-windows编程-删除文件至回收站</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/setup/">Python-打包并发布代码至 PyPI</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/pywasm/overview/">Python-pywasm-美味尝鲜</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../py/pywasm/leb128/">Python-pywasm-LEB128</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/read_file/">Go-按行读取文件</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/socket/">Go-socket</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/socket_not_accept/">Go-socket-假如服务端不调用 Accept</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/tls/">Go-tls</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/socks5/">Go-socks-version-5</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/cross_compiling/">Go-交叉编译</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/end_of_time/">Go-时间尽头</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/token_bucket/">Go-流量限制</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/fswatch/">Go-目录监听</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../go/cgo/">Go-Cgo</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../ahk/overview/">AHK-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../ahk/clicker/">AHK-实现鼠标连点器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../ahk/color/">AHK-实现屏幕取色器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../ahk/longpress/">AHK-长按</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../ahk/loopread/">AHK-按行读取文件</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../rust/overview/">Rust-概览</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../rust/io/">Rust-文件读取</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../rust/http/">Rust-HTTP</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../rust/concurrent/">Rust-并发</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../rust/tcp/">Rust-TCP</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../rust/json/">Rust-JSON</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">区块链</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../blockchain/evm/">EVM</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../blockchain/merkle_tree/">Merkle Tree</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">竹书纪年</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../diary/2019/">Y2019</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../diary/2020/">Y2020</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">演讲</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../speech/minits/">minits, 以 LLVM 为后端的 TypeScript 静态编译器</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../speech/blockchain_privacy_protection/">区块链隐私保护密码技术介绍</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../..">Mohanson</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../..">Docs</a> &raquo;</li>
    
      
        
          <li>自己动手写 Game Boy 仿真器 &raquo;</li>
        
      
    
    <li>GB-CPU-LR35902标准指令集</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/mohanson/accu/edit/master/docs/content/gameboy/cpu/lr35902_standard.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="lr35902">LR35902 标准指令集</h1>
<p>LR35902 拥有两套指令集, 一套是 8 位指令集, 另一套则是 16 位指令集, 其中 16 位指令集的操作码固定以 0xcb 作为前缀. 16 位指令集也常被称作扩展指令集, 因为原版 z80 CPU 不支持移位操作, 所以 LR35902 通过外接扩展电路的形式额外添加了移位指令.</p>
<p>关于其标准指令集与扩张指令集, 可以在网站 <a href="http://www.pastraiser.com/cpu/gameboy/gameboy_opcodes.html">http://www.pastraiser.com/cpu/gameboy/gameboy_opcodes.html</a> 上找到它的简要概览.</p>
<p>我们首先将聚焦在标准指令集上, 这套指令被同时应用在诸如 Intel 8080, z80 和 LR35902 等 CPU 上, 更是如今 x86 架构的前身. 请注意, 对 CPU 指令集的仿真是一个繁琐且不能出任何差错的工程, 初学者通常会花大量的时间在调式上. 更糟糕的是, 除非已经完成了整个项目, 不然几乎无法在开发阶段验证自己写的代码是否正确. 因此请做好准备, 并且在遇到困难时不必过于沮丧!</p>
<h1 id="_1">结构体定义</h1>
<p>在开始之前, 定义如下的对 CPU 结构进行仿真的结构体, 后续所有的开发都将围绕该结构体进行.</p>
<pre><code class="rs">pub struct Cpu {
    pub reg: Register,                // 寄存器
    pub mem: Rc&lt;RefCell&lt;dyn Memory&gt;&gt;, // 可访问的内存空间
    pub halted: bool,                 // 表明 CPU 是否处于工作状态
    pub ei: bool,                     // enable interrupt 的简写, 表明 CPU 是否接收硬件中断
}
</code></pre>

<p>同时为该结构体实现两个根据当前 PC 从内存中读取 u8 和 u16 的两个函数, 记得读取数据后需要准确地移动 PC: 如果读取的是 u8 数据则 PC 加 1, 如果是 u16 数据则 PC 加 2.</p>
<pre><code class="rs">impl Cpu {
    fn imm(&amp;mut self) -&gt; u8 {
        let v = self.mem.borrow().get(self.reg.pc);
        self.reg.pc += 1;
        v
    }

    fn imm_word(&amp;mut self) -&gt; u16 {
        let v = self.mem.borrow().get_word(self.reg.pc);
        self.reg.pc += 2;
        v
    }
}
</code></pre>

<p>此处需要注意一个细节, u16 数据低位数据在内存前半部分, 高位数据在后半部分. 比如数字 0x0150, 其内存分布则是 0x50, 0x01. 这在计算机中被称为小端序(Little endian).</p>
<h1 id="_2">如何取指与执行</h1>
<p>CPU 总是不断的根据当前 PC 进行取指过程, 并且在指令被取指后, 进入指令执行过程. 为 CPU 添加如下的指令执行函数:</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        ...
    }
}
</code></pre>

<p>其中 Opcode 为操作码, 不同的 Opcode 代表不同的指令, 在代码实现中需要使用 match 语句对 Opcode 进行匹配. 该函数返回一个 u32, 代表该指令所消耗的机器周期(CPU 执行该指令所花费的时间).</p>
<p>下面给出了标准指令的摘要与仿真实现. 如果该指令影响了标志位寄存器 Flag, 则会在指令描述中特别指明. 在此约定指令的书写方法如下:</p>
<pre><code class="text">Instruction (Parameter1) (Parameter2)
</code></pre>

<ul>
<li>Instruction: 指令的英文缩写</li>
<li>Parameter1/Parameter2: 指令的参数</li>
</ul>
<p>其中 Parameter 可以是如下几种情况之一:</p>
<ul>
<li>特定寄存器: 特定的目标寄存器, 可以是任意 8 位寄存器或 16 位组合寄存器之一.</li>
<li>r8: 8 位寄存器. 可以是寄存器 A, F, B, C, D, E, H 或 L.</li>
<li>d8: 8 位立即数. 立即数是指采用立即寻址方式指令中给出的数, 该数值紧跟在操作码之后.</li>
<li>r16: 16 位寄存器. 可以是寄存器 AF, BC, DE 或 HL.</li>
<li>d16: 16位立即数.</li>
<li>(r16): 以 16 位寄存器所存储数据视为内存地址取得的数</li>
<li>(d16): 以 16 位立即数所存储数据视为内存地址取得的数</li>
<li>(a8): 以 0xff00 与 8 位立即参数的或运算结果视为内存地址取得的数</li>
</ul>
<h1 id="8">8 位数据加载</h1>
<p><strong>LD r8, d8</strong></p>
<p>1) 描述</p>
<p>将一个 8 位的立即参数写入到相应的 8 位寄存器中.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<p>下表分为 4 列, 第一列 Instruction 表示指令的缩写类型, 第二列 Parameters 表示详细的参数签名, 第三列 Opcode 为指令的操作码(16进制表示), 最后一列 Cycles 为指令所需消耗的时钟周期. 比如下表第一行, 就表示如果 CPU 从内存中读取到 0x06, 则将之视为 LD B, n 指令处理, 处理过程将消耗 8 个时钟周期. 后文同.</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>LD</td>
<td>B, n</td>
<td>06</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>C, n</td>
<td>0e</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>D, n</td>
<td>16</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>E, n</td>
<td>1e</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>H, n</td>
<td>26</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>L, n</td>
<td>2e</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>(HL), n</td>
<td>36</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>A, n</td>
<td>3e</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<p>指令的仿真代码需填写入前文的 ex() 函数的 match 语句内. 数据加载的代码实现较为简单, 首先使用 self.imm() 读取一个 8 位立即数, 然后赋值到对应的寄存器即可. 稍微需要注意的是 Opcode 为 36 时, 立即数不是赋值给 HL 寄存器, 而是赋值给以 HL 寄存器存储数据为地址的内存中.</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x06 =&gt; self.reg.b = self.imm(),
        0x0e =&gt; self.reg.c = self.imm(),
        0x16 =&gt; self.reg.d = self.imm(),
        0x1e =&gt; self.reg.e = self.imm(),
        0x26 =&gt; self.reg.h = self.imm(),
        0x2e =&gt; self.reg.l = self.imm(),
        0x36 =&gt; {
            let a = self.reg.get_hl();
            let v = self.imm();
            self.mem.borrow_mut().set(a, v);
        }
        0x3e =&gt; self.reg.a = self.imm(),
        ...
    }
}
</code></pre>

<p><strong>LD r8, r8</strong></p>
<p>1) 描述</p>
<p>将一个 8 位寄存器的值写入到另一个 8 位寄存器.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>LD</td>
<td>B, B</td>
<td>40</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>B, C</td>
<td>41</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>B, D</td>
<td>42</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>B, E</td>
<td>43</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>B, H</td>
<td>44</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>B, L</td>
<td>45</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>B, (HL)</td>
<td>46</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>B, A</td>
<td>47</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>C, B</td>
<td>48</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>C, C</td>
<td>49</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>C, D</td>
<td>4A</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>C, E</td>
<td>4B</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>C, H</td>
<td>4C</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>C, L</td>
<td>4D</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>C, (HL)</td>
<td>4E</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>C, A</td>
<td>4F</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>D, B</td>
<td>50</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>D, C</td>
<td>51</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>D, D</td>
<td>52</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>D, E</td>
<td>53</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>D, H</td>
<td>54</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>D, L</td>
<td>55</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>D, (HL)</td>
<td>56</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>D, A</td>
<td>57</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>E, B</td>
<td>58</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>E, C</td>
<td>59</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>E, D</td>
<td>5A</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>E, E</td>
<td>5B</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>E, H</td>
<td>5C</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>E, L</td>
<td>5D</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>E, (HL)</td>
<td>5E</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>E, A</td>
<td>5F</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>H, B</td>
<td>60</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>H, C</td>
<td>61</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>H, D</td>
<td>62</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>H, E</td>
<td>63</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>H, H</td>
<td>64</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>H, L</td>
<td>65</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>H, (HL)</td>
<td>66</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>H, A</td>
<td>67</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>L, B</td>
<td>68</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>L, C</td>
<td>69</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>L, D</td>
<td>6A</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>L, E</td>
<td>6B</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>L, H</td>
<td>6C</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>L, L</td>
<td>6D</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>L, (HL)</td>
<td>6E</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>L, A</td>
<td>6F</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>(HL), B</td>
<td>70</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>(HL), C</td>
<td>71</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>(HL), D</td>
<td>72</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>(HL), E</td>
<td>73</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>(HL), H</td>
<td>74</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>(HL), L</td>
<td>75</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>(HL), A</td>
<td>77</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>A, B</td>
<td>78</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>A, C</td>
<td>79</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>A, D</td>
<td>7A</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>A, E</td>
<td>7B</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>A, H</td>
<td>7C</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>A, L</td>
<td>7D</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>A, (HL)</td>
<td>7E</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>A, A</td>
<td>7F</td>
<td>4</td>
</tr>
<tr>
<td>LD</td>
<td>(BC), A</td>
<td>02</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>(DE), A</td>
<td>12</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>A, (BC)</td>
<td>0a</td>
<td>8</td>
</tr>
<tr>
<td>LD</td>
<td>A, (DE)</td>
<td>1a</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>表中有一类指令可能会引起读者困惑, 以 0x40 Opcode 为例, 它可表示为 LD B, B, 其两个参数均是 B, 其含义是"读取寄存器 B 的值, 并写入寄存器 B". 从结果上来说, 它不会引起任何寄存器内容的变化, 但该操作仍然需要消耗 CPU 的时钟周期. 在后文会有专门章节对此进行介绍.</p>
<p>4) 代码实现</p>
<p>代码实现相对简单, 只需要读取对应的 8 位数据并写入目标寄存器即可.</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x40 =&gt; {}
        0x41 =&gt; self.reg.b = self.reg.c,
        0x42 =&gt; self.reg.b = self.reg.d,
        0x43 =&gt; self.reg.b = self.reg.e,
        0x44 =&gt; self.reg.b = self.reg.h,
        0x45 =&gt; self.reg.b = self.reg.l,
        0x46 =&gt; self.reg.b = self.mem.borrow().get(self.reg.get_hl()),
        0x47 =&gt; self.reg.b = self.reg.a,
        0x48 =&gt; self.reg.c = self.reg.b,
        0x49 =&gt; {}
        0x4a =&gt; self.reg.c = self.reg.d,
        0x4b =&gt; self.reg.c = self.reg.e,
        0x4c =&gt; self.reg.c = self.reg.h,
        0x4d =&gt; self.reg.c = self.reg.l,
        0x4e =&gt; self.reg.c = self.mem.borrow().get(self.reg.get_hl()),
        0x4f =&gt; self.reg.c = self.reg.a,
        0x50 =&gt; self.reg.d = self.reg.b,
        0x51 =&gt; self.reg.d = self.reg.c,
        0x52 =&gt; {}
        0x53 =&gt; self.reg.d = self.reg.e,
        0x54 =&gt; self.reg.d = self.reg.h,
        0x55 =&gt; self.reg.d = self.reg.l,
        0x56 =&gt; self.reg.d = self.mem.borrow().get(self.reg.get_hl()),
        0x57 =&gt; self.reg.d = self.reg.a,
        0x58 =&gt; self.reg.e = self.reg.b,
        0x59 =&gt; self.reg.e = self.reg.c,
        0x5a =&gt; self.reg.e = self.reg.d,
        0x5b =&gt; {}
        0x5c =&gt; self.reg.e = self.reg.h,
        0x5d =&gt; self.reg.e = self.reg.l,
        0x5e =&gt; self.reg.e = self.mem.borrow().get(self.reg.get_hl()),
        0x5f =&gt; self.reg.e = self.reg.a,
        0x60 =&gt; self.reg.h = self.reg.b,
        0x61 =&gt; self.reg.h = self.reg.c,
        0x62 =&gt; self.reg.h = self.reg.d,
        0x63 =&gt; self.reg.h = self.reg.e,
        0x64 =&gt; {}
        0x65 =&gt; self.reg.h = self.reg.l,
        0x66 =&gt; self.reg.h = self.mem.borrow().get(self.reg.get_hl()),
        0x67 =&gt; self.reg.h = self.reg.a,
        0x68 =&gt; self.reg.l = self.reg.b,
        0x69 =&gt; self.reg.l = self.reg.c,
        0x6a =&gt; self.reg.l = self.reg.d,
        0x6b =&gt; self.reg.l = self.reg.e,
        0x6c =&gt; self.reg.l = self.reg.h,
        0x6d =&gt; {}
        0x6e =&gt; self.reg.l = self.mem.borrow().get(self.reg.get_hl()),
        0x6f =&gt; self.reg.l = self.reg.a,
        0x70 =&gt; self.mem.borrow_mut().set(self.reg.get_hl(), self.reg.b),
        0x71 =&gt; self.mem.borrow_mut().set(self.reg.get_hl(), self.reg.c),
        0x72 =&gt; self.mem.borrow_mut().set(self.reg.get_hl(), self.reg.d),
        0x73 =&gt; self.mem.borrow_mut().set(self.reg.get_hl(), self.reg.e),
        0x74 =&gt; self.mem.borrow_mut().set(self.reg.get_hl(), self.reg.h),
        0x75 =&gt; self.mem.borrow_mut().set(self.reg.get_hl(), self.reg.l),
        0x77 =&gt; self.mem.borrow_mut().set(self.reg.get_hl(), self.reg.a),
        0x78 =&gt; self.reg.a = self.reg.b,
        0x79 =&gt; self.reg.a = self.reg.c,
        0x7a =&gt; self.reg.a = self.reg.d,
        0x7b =&gt; self.reg.a = self.reg.e,
        0x7c =&gt; self.reg.a = self.reg.h,
        0x7d =&gt; self.reg.a = self.reg.l,
        0x7e =&gt; self.reg.a = self.mem.borrow().get(self.reg.get_hl()),
        0x7f =&gt; {},
        0x02 =&gt; self.mem.borrow_mut().set(self.reg.get_bc(), self.reg.a),
        0x12 =&gt; self.mem.borrow_mut().set(self.reg.get_de(), self.reg.a),
        0x0a =&gt; self.reg.a = self.mem.borrow().get(self.reg.get_bc()),
        0x1a =&gt; self.reg.a = self.mem.borrow().get(self.reg.get_de()),
        ...
    }
}
</code></pre>

<p><strong>LD (C), A</strong></p>
<p>1) 描述</p>
<p>将寄存器 A 的值写入目标内存地址(由 0xff00 | 寄存器 C 指定).</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>LD</td>
<td>(C), A</td>
<td>e2</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xe2 =&gt; self.mem.borrow_mut().set(0xff00 | u16::from(self.reg.c), self.reg.a),
        ...
    }
}
</code></pre>

<p><strong>LD A, (C)</strong></p>
<p>1) 描述</p>
<p>将目标内存地址(由 0xff00 | 寄存器 C 指定)的值写入寄存器 A.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>LD</td>
<td>A, (C)</td>
<td>f2</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xf2 =&gt; self.reg.a = self.mem.borrow().get(0xff00 | u16::from(self.reg.c)),
        ...
    }
}
</code></pre>

<p><strong>LD (HL+), A</strong></p>
<p>1) 描述</p>
<p>将寄存器 A 写入目标内存地址(由 HL 寄存器指定), 同时 HL 自增.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>LD</td>
<td>(HL+), A</td>
<td>22</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x22 =&gt; {
            let a = self.reg.get_hl();
            self.mem.borrow_mut().set(a, self.reg.a);
            self.reg.set_hl(a + 1);
        }
        ...
    }
}
</code></pre>

<p><strong>LD (HL-), A</strong></p>
<p>1) 描述</p>
<p>将寄存器 A 写入目标内存地址(由 HL 寄存器指定), 同时 HL 自减.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>LD</td>
<td>(HL-), A</td>
<td>22</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x32 =&gt; {
            let a = self.reg.get_hl();
            self.mem.borrow_mut().set(a, self.reg.a);
            self.reg.set_hl(a - 1);
        }
        ...
    }
}
</code></pre>

<p><strong>LD A, (HL+)</strong></p>
<p>1) 描述</p>
<p>将目标内存地址(由 HL 寄存器指定)的值写入寄存器 A, 同时 HL 自增.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>LD</td>
<td>A, (HL+)</td>
<td>22</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x2a =&gt; {
            let v = self.reg.get_hl();
            self.reg.a = self.mem.borrow().get(v);
            self.reg.set_hl(v + 1);
        }
        ...
    }
}
</code></pre>

<p><strong>LD A, (HL-)</strong></p>
<p>1) 描述</p>
<p>将目标内存地址(由 HL 寄存器指定)的值写入寄存器 A, 同时 HL 自减.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>LD</td>
<td>A, (HL-)</td>
<td>22</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x3a =&gt; {
            let v = self.reg.get_hl();
            self.reg.a = self.mem.borrow().get(v);
            self.reg.set_hl(v - 1);
        }
        ...
    }
}
</code></pre>

<p><strong>LD (d8), A</strong></p>
<p>1) 描述</p>
<p>将寄存器 A 的值写入目标内存地址(由 0xff00 | 8 位立即参数指定).</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>LD</td>
<td>(d8), A</td>
<td>e0</td>
<td>12</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xe0 =&gt; {
            let a = 0xff00 | u16::from(self.imm());
            self.mem.borrow_mut().set(a, self.reg.a);
        }
        ...
    }
}
</code></pre>

<p><strong>LD A, (a8)</strong></p>
<p>1) 描述</p>
<p>将目标内存地址(由 0xff00 | 8 位立即参数指定)的值写入寄存器 A.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>LD</td>
<td>A, (d8)</td>
<td>f0</td>
<td>12</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xf0 =&gt; {
            let a = 0xff00 | u16::from(self.imm());
            self.reg.a = self.mem.borrow().get(a);
        }
        ...
    }
}
</code></pre>

<p><strong>LD (d16), A</strong></p>
<p>1) 描述</p>
<p>将寄存器 A 的值写入目标内存地址(由 16 位立即参数指定).</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>LD</td>
<td>(a16), A</td>
<td>ea</td>
<td>16</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xea =&gt; {
            let a = self.imm_word();
            self.mem.borrow_mut().set(a, self.reg.a);
        }
        ...
    }
}
</code></pre>

<p><strong>LD A, (d16)</strong></p>
<p>1) 描述</p>
<p>将目标内存地址(由 16 位立即参数指定)的值写入寄存器 A.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>LD</td>
<td>A, (a16)</td>
<td>fa</td>
<td>16</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xfa =&gt; {
            let a = self.imm_word();
            self.reg.a = self.mem.borrow().get(a);
        }
        ...
    }
}
</code></pre>

<h1 id="16">16 位数据加载</h1>
<p><strong>LD r16, d16</strong></p>
<p>1) 描述</p>
<p>将 16 位立即参数写入相应 16 位寄存器中.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>LD</td>
<td>BC, d16</td>
<td>01</td>
<td>12</td>
</tr>
<tr>
<td>LD</td>
<td>DE, d16</td>
<td>11</td>
<td>12</td>
</tr>
<tr>
<td>LD</td>
<td>HL, d16</td>
<td>21</td>
<td>12</td>
</tr>
<tr>
<td>LD</td>
<td>SP, d16</td>
<td>31</td>
<td>12</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x01 | 0x11 | 0x21 | 0x31 =&gt; {
            let v = self.imm_word();
            match opcode {
                0x01 =&gt; self.reg.set_bc(v),
                0x11 =&gt; self.reg.set_de(v),
                0x21 =&gt; self.reg.set_hl(v),
                0x31 =&gt; self.reg.sp = v,
                _ =&gt; {}
            }
        }
        ...
    }
}
</code></pre>

<p><strong>LD SP, HL</strong></p>
<p>1) 描述</p>
<p>将寄存器 HL 写入到寄存器 SP.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>LD</td>
<td>SP, HL</td>
<td>f9</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xf9 =&gt; self.reg.sp = self.reg.get_hl(),
        ...
    }
}
</code></pre>

<p><strong>LD HL, SP + d8</strong></p>
<p>1) 描述</p>
<p>将 SP 寄存器 + 有符号 8 位立即参数的结果写入寄存器 HL.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 置零</li>
<li>N - 置零</li>
<li>H - 第 3 位进位时, 则置位</li>
<li>C - 第 7 位进位时, 则置位</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>LD</td>
<td>SP, d8</td>
<td>f8</td>
<td>12</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xf8 =&gt; {
            let a = self.reg.sp;
            let b = i16::from(self.imm() as i8) as u16;
            self.reg.set_flag(C, (a &amp; 0x00ff) + (b &amp; 0x00ff) &gt; 0x00ff);
            self.reg.set_flag(H, (a &amp; 0x000f) + (b &amp; 0x000f) &gt; 0x000f);
            self.reg.set_flag(N, false);
            self.reg.set_flag(Z, false);
            self.reg.set_hl(a.wrapping_add(b));
        }
        ...
    }
}
</code></pre>

<p><strong>LD (d16), SP</strong></p>
<p>1) 描述</p>
<p>将 SP 寄存器的值写入目标内存地址(由 16 位立即参数指定).</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>LD</td>
<td>(d16), SP</td>
<td>0x08</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x08 =&gt; {
            let a = self.imm_word();
            self.mem.borrow_mut().set_word(a, self.reg.sp);
        }
        ...
    }
}
</code></pre>

<p><strong>PUSH</strong></p>
<p>1) 描述</p>
<p>栈指令. 将相应 16 位寄存器的值入栈.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>PUSH</td>
<td>BC</td>
<td>0xc5</td>
<td>20</td>
</tr>
<tr>
<td>PUSH</td>
<td>DE</td>
<td>0xd5</td>
<td>20</td>
</tr>
<tr>
<td>PUSH</td>
<td>HL</td>
<td>0xe5</td>
<td>20</td>
</tr>
<tr>
<td>PUSH</td>
<td>AF</td>
<td>0xf5</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    fn stack_push(&amp;mut self, v: u16) {
        self.reg.sp -= 2;
        self.mem.borrow_mut().set_word(self.reg.sp, v);
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xc5 =&gt; self.stack_add(self.reg.get_bc()),
        0xd5 =&gt; self.stack_add(self.reg.get_de()),
        0xe5 =&gt; self.stack_add(self.reg.get_hl()),
        0xf5 =&gt; self.stack_add(self.reg.get_af()),
        ...
    }
}
</code></pre>

<p><strong>POP</strong></p>
<p>1) 描述</p>
<p>栈指令. 出栈并将数据写入相应 16 位寄存器.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>POP</td>
<td>BC</td>
<td>0xc1</td>
<td>20</td>
</tr>
<tr>
<td>POP</td>
<td>DE</td>
<td>0xd1</td>
<td>20</td>
</tr>
<tr>
<td>POP</td>
<td>HL</td>
<td>0xe1</td>
<td>20</td>
</tr>
<tr>
<td>POP</td>
<td>AF</td>
<td>0xf1</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    fn stack_pop(&amp;mut self) -&gt; u16 {
        let r = self.mem.borrow().get_word(self.reg.sp);
        self.reg.sp += 2;
        r
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xc1 | 0xf1 | 0xd1 | 0xe1 =&gt; {
            let v = self.stack_pop();
            match opcode {
                0xc1 =&gt; self.reg.set_bc(v),
                0xd1 =&gt; self.reg.set_de(v),
                0xe1 =&gt; self.reg.set_hl(v),
                0xf1 =&gt; self.reg.set_af(v),
                _ =&gt; {}
            }
        }
        ...
    }
}
</code></pre>

<h1 id="8_1">8 位算数逻辑运算</h1>
<p><strong>ADD A, r8/d8</strong></p>
<p>1) 描述</p>
<p>算术加法运算. 将指定的 8 位数与寄存器 A 相加, 并将结果回写入寄存器 A.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 计算结果为零, 则置位</li>
<li>N - 置零</li>
<li>H - 第 3 位进位时, 则置位</li>
<li>C - 第 7 位进位时, 则置位</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>ADD</td>
<td>B</td>
<td>0x80</td>
<td>4</td>
</tr>
<tr>
<td>ADD</td>
<td>C</td>
<td>0x81</td>
<td>4</td>
</tr>
<tr>
<td>ADD</td>
<td>D</td>
<td>0x82</td>
<td>4</td>
</tr>
<tr>
<td>ADD</td>
<td>E</td>
<td>0x83</td>
<td>4</td>
</tr>
<tr>
<td>ADD</td>
<td>H</td>
<td>0x84</td>
<td>4</td>
</tr>
<tr>
<td>ADD</td>
<td>L</td>
<td>0x85</td>
<td>4</td>
</tr>
<tr>
<td>ADD</td>
<td>(HL)</td>
<td>0x86</td>
<td>8</td>
</tr>
<tr>
<td>ADD</td>
<td>A</td>
<td>0x87</td>
<td>4</td>
</tr>
<tr>
<td>ADD</td>
<td>(d8)</td>
<td>0xc6</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Add n to A.
    // n = A,B,C,D,E,H,L,(HL),#
    //
    // Flags affected:
    // Z - Set if result is zero.
    // N - Reset.
    // H - Set if carry from bit 3.
    // C - Set if carry from bit 7.
    fn alu_add(&amp;mut self, n: u8) {
        let a = self.reg.a;
        let r = a.wrapping_add(n);
        self.reg.set_flag(C, u16::from(a) + u16::from(n) &gt; 0xff);
        self.reg.set_flag(H, (a &amp; 0x0f) + (n &amp; 0x0f) &gt; 0x0f);
        self.reg.set_flag(N, false);
        self.reg.set_flag(Z, r == 0x00);
        self.reg.a = r;
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x80 =&gt; self.alu_add(self.reg.b),
        0x81 =&gt; self.alu_add(self.reg.c),
        0x82 =&gt; self.alu_add(self.reg.d),
        0x83 =&gt; self.alu_add(self.reg.e),
        0x84 =&gt; self.alu_add(self.reg.h),
        0x85 =&gt; self.alu_add(self.reg.l),
        0x86 =&gt; {
            let v = self.mem.borrow().get(self.reg.get_hl());
            self.alu_add(v);
        }
        0x87 =&gt; self.alu_add(self.reg.a),
        0xc6 =&gt; {
            let v = self.imm();
            self.alu_add(v);
        }
        ...
    }
}
</code></pre>

<p><strong>ADC A, r8/d8</strong></p>
<p>1) 描述</p>
<p>带进位的算术加法运算.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 计算结果为零, 则置位</li>
<li>N - 置零</li>
<li>H - 第 3 位进位时, 则置位</li>
<li>C - 第 7 位进位时, 则置位</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>ADC</td>
<td>B</td>
<td>0x88</td>
<td>4</td>
</tr>
<tr>
<td>ADC</td>
<td>C</td>
<td>0x89</td>
<td>4</td>
</tr>
<tr>
<td>ADC</td>
<td>D</td>
<td>0x8a</td>
<td>4</td>
</tr>
<tr>
<td>ADC</td>
<td>E</td>
<td>0x8b</td>
<td>4</td>
</tr>
<tr>
<td>ADC</td>
<td>H</td>
<td>0x8c</td>
<td>4</td>
</tr>
<tr>
<td>ADC</td>
<td>L</td>
<td>0x8d</td>
<td>4</td>
</tr>
<tr>
<td>ADC</td>
<td>(HL)</td>
<td>0x8e</td>
<td>8</td>
</tr>
<tr>
<td>ADC</td>
<td>A</td>
<td>0x8f</td>
<td>4</td>
</tr>
<tr>
<td>ADC</td>
<td>(d8)</td>
<td>0xce</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Add n to A.
    // n = A,B,C,D,E,H,L,(HL),#
    //
    // Flags affected:
    // Z - Set if result is zero.
    // N - Reset.
    // H - Set if carry from bit 3.
    // C - Set if carry from bit 7.
    fn alu_adc(&amp;mut self, n: u8) {
        let a = self.reg.a;
        let c = u8::from(self.reg.get_flag(C));
        let r = a.wrapping_add(n).wrapping_add(c);
        self.reg
            .set_flag(C, u16::from(a) + u16::from(n) + u16::from(c) &gt; 0xff);
        self.reg
            .set_flag(H, (a &amp; 0x0f) + (n &amp; 0x0f) + (c &amp; 0x0f) &gt; 0x0f);
        self.reg.set_flag(N, false);
        self.reg.set_flag(Z, r == 0x00);
        self.reg.a = r;
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x88 =&gt; self.alu_adc(self.reg.b),
        0x89 =&gt; self.alu_adc(self.reg.c),
        0x8a =&gt; self.alu_adc(self.reg.d),
        0x8b =&gt; self.alu_adc(self.reg.e),
        0x8c =&gt; self.alu_adc(self.reg.h),
        0x8d =&gt; self.alu_adc(self.reg.l),
        0x8e =&gt; {
            let a = self.mem.borrow().get(self.reg.get_hl());
            self.alu_adc(a);
        }
        0x8f =&gt; self.alu_adc(self.reg.a),
        0xce =&gt; {
            let v = self.imm();
            self.alu_adc(v);
        }
        ...
    }
}
</code></pre>

<p><strong>SUB A, r8/d8</strong></p>
<p>1) 描述</p>
<p>算术减法运算.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 计算结果为零, 则置位</li>
<li>N - 置位</li>
<li>H - 第 4 位借位时, 则置位</li>
<li>C - 没有发生借位, 则置位</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>SUB</td>
<td>B</td>
<td>0x90</td>
<td>4</td>
</tr>
<tr>
<td>SUB</td>
<td>C</td>
<td>0x91</td>
<td>4</td>
</tr>
<tr>
<td>SUB</td>
<td>D</td>
<td>0x92</td>
<td>4</td>
</tr>
<tr>
<td>SUB</td>
<td>E</td>
<td>0x93</td>
<td>4</td>
</tr>
<tr>
<td>SUB</td>
<td>H</td>
<td>0x94</td>
<td>4</td>
</tr>
<tr>
<td>SUB</td>
<td>L</td>
<td>0x95</td>
<td>4</td>
</tr>
<tr>
<td>SUB</td>
<td>(HL)</td>
<td>0x96</td>
<td>8</td>
</tr>
<tr>
<td>SUB</td>
<td>A</td>
<td>0x97</td>
<td>4</td>
</tr>
<tr>
<td>SUB</td>
<td>(d8)</td>
<td>0xd6</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Subtract n from A.
    // n = A,B,C,D,E,H,L,(HL),#
    //
    // Flags affected:
    // Z - Set if result is zero.
    // N - Set.
    // H - Set if no borrow from bit 4.
    // C - Set if no borrow
    fn alu_sub(&amp;mut self, n: u8) {
        let a = self.reg.a;
        let r = a.wrapping_sub(n);
        self.reg.set_flag(C, u16::from(a) &lt; u16::from(n));
        self.reg.set_flag(H, (a &amp; 0x0f) &lt; (n &amp; 0x0f));
        self.reg.set_flag(N, true);
        self.reg.set_flag(Z, r == 0x00);
        self.reg.a = r;
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x90 =&gt; self.alu_sub(self.reg.b),
        0x91 =&gt; self.alu_sub(self.reg.c),
        0x92 =&gt; self.alu_sub(self.reg.d),
        0x93 =&gt; self.alu_sub(self.reg.e),
        0x94 =&gt; self.alu_sub(self.reg.h),
        0x95 =&gt; self.alu_sub(self.reg.l),
        0x96 =&gt; {
            let a = self.mem.borrow().get(self.reg.get_hl());
            self.alu_sub(a);
        }
        0x97 =&gt; self.alu_sub(self.reg.a),
        0xd6 =&gt; {
            let v = self.imm();
            self.alu_sub(v);
        }
        ...
    }
}
</code></pre>

<p><strong>SBC A, r8/d8</strong></p>
<p>1) 描述</p>
<p>带借位的算术减法运算.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 计算结果为零, 则置位</li>
<li>N - 置位</li>
<li>H - 第 4 位借位时, 则置位</li>
<li>C - 没有发生借位, 则置位</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>SBC</td>
<td>B</td>
<td>0x98</td>
<td>4</td>
</tr>
<tr>
<td>SBC</td>
<td>C</td>
<td>0x99</td>
<td>4</td>
</tr>
<tr>
<td>SBC</td>
<td>D</td>
<td>0x9a</td>
<td>4</td>
</tr>
<tr>
<td>SBC</td>
<td>E</td>
<td>0x9b</td>
<td>4</td>
</tr>
<tr>
<td>SBC</td>
<td>H</td>
<td>0x9c</td>
<td>4</td>
</tr>
<tr>
<td>SBC</td>
<td>L</td>
<td>0x9d</td>
<td>4</td>
</tr>
<tr>
<td>SBC</td>
<td>(HL)</td>
<td>0x9e</td>
<td>8</td>
</tr>
<tr>
<td>SBC</td>
<td>A</td>
<td>0x9f</td>
<td>4</td>
</tr>
<tr>
<td>SBC</td>
<td>(d8)</td>
<td>0xde</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Subtract n + Carry flag from A.
    // n = A,B,C,D,E,H,L,(HL),#
    //
    // Flags affected:
    // Z - Set if result is zero.
    // N - Set.
    // H - Set if no borrow from bit 4.
    // C - Set if no borrow.
    fn alu_sbc(&amp;mut self, n: u8) {
        let a = self.reg.a;
        let c = u8::from(self.reg.get_flag(C));
        let r = a.wrapping_sub(n).wrapping_sub(c);
        self.reg
            .set_flag(C, u16::from(a) &lt; u16::from(n) + u16::from(c));
        self.reg.set_flag(H, (a &amp; 0x0f) &lt; (n &amp; 0x0f) + c);
        self.reg.set_flag(N, true);
        self.reg.set_flag(Z, r == 0x00);
        self.reg.a = r;
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x98 =&gt; self.alu_sbc(self.reg.b),
        0x99 =&gt; self.alu_sbc(self.reg.c),
        0x9a =&gt; self.alu_sbc(self.reg.d),
        0x9b =&gt; self.alu_sbc(self.reg.e),
        0x9c =&gt; self.alu_sbc(self.reg.h),
        0x9d =&gt; self.alu_sbc(self.reg.l),
        0x9e =&gt; {
            let a = self.mem.borrow().get(self.reg.get_hl());
            self.alu_sbc(a);
        }
        0x9f =&gt; self.alu_sbc(self.reg.a),
        0xde =&gt; {
            let v = self.imm();
            self.alu_sbc(v);
        }
        ...
    }
}
</code></pre>

<p><strong>AND A, r8/d8</strong></p>
<p>1) 描述</p>
<p>逻辑和运算.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 计算结果为零, 则置位</li>
<li>N - 置零</li>
<li>H - 置位</li>
<li>C - 置零</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>AND</td>
<td>B</td>
<td>0xa0</td>
<td>4</td>
</tr>
<tr>
<td>AND</td>
<td>C</td>
<td>0xa1</td>
<td>4</td>
</tr>
<tr>
<td>AND</td>
<td>D</td>
<td>0xa2</td>
<td>4</td>
</tr>
<tr>
<td>AND</td>
<td>E</td>
<td>0xa3</td>
<td>4</td>
</tr>
<tr>
<td>AND</td>
<td>H</td>
<td>0xa4</td>
<td>4</td>
</tr>
<tr>
<td>AND</td>
<td>L</td>
<td>0xa5</td>
<td>4</td>
</tr>
<tr>
<td>AND</td>
<td>(HL)</td>
<td>0xa6</td>
<td>8</td>
</tr>
<tr>
<td>AND</td>
<td>A</td>
<td>0xa7</td>
<td>4</td>
</tr>
<tr>
<td>AND</td>
<td>(d8)</td>
<td>0xe6</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Logically AND n with A, result in A.
    // n = A,B,C,D,E,H,L,(HL),#
    //
    // Flags affected:
    // Z - Set if result is zero.
    // N - Reset.
    // H - Set.
    // C - Reset
    fn alu_and(&amp;mut self, n: u8) {
        let r = self.reg.a &amp; n;
        self.reg.set_flag(C, false);
        self.reg.set_flag(H, true);
        self.reg.set_flag(N, false);
        self.reg.set_flag(Z, r == 0x00);
        self.reg.a = r;
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xa0 =&gt; self.alu_and(self.reg.b),
        0xa1 =&gt; self.alu_and(self.reg.c),
        0xa2 =&gt; self.alu_and(self.reg.d),
        0xa3 =&gt; self.alu_and(self.reg.e),
        0xa4 =&gt; self.alu_and(self.reg.h),
        0xa5 =&gt; self.alu_and(self.reg.l),
        0xa6 =&gt; {
            let a = self.mem.borrow().get(self.reg.get_hl());
            self.alu_and(a);
        }
        0xa7 =&gt; self.alu_and(self.reg.a),
        0xe6 =&gt; {
            let v = self.imm();
            self.alu_and(v);
        }
        ...
    }
}
</code></pre>

<p><strong>OR A, r8/d8</strong></p>
<p>1) 描述</p>
<p>逻辑或运算.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 计算结果为零, 则置位</li>
<li>N - 置零</li>
<li>H - 置零</li>
<li>C - 置零</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>OR</td>
<td>B</td>
<td>0xb0</td>
<td>4</td>
</tr>
<tr>
<td>OR</td>
<td>C</td>
<td>0xb1</td>
<td>4</td>
</tr>
<tr>
<td>OR</td>
<td>D</td>
<td>0xb2</td>
<td>4</td>
</tr>
<tr>
<td>OR</td>
<td>E</td>
<td>0xb3</td>
<td>4</td>
</tr>
<tr>
<td>OR</td>
<td>H</td>
<td>0xb4</td>
<td>4</td>
</tr>
<tr>
<td>OR</td>
<td>L</td>
<td>0xb5</td>
<td>4</td>
</tr>
<tr>
<td>OR</td>
<td>(HL)</td>
<td>0xb6</td>
<td>8</td>
</tr>
<tr>
<td>OR</td>
<td>A</td>
<td>0xb7</td>
<td>4</td>
</tr>
<tr>
<td>OR</td>
<td>(d8)</td>
<td>0xf6</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Logical OR n with register A, result in A.
    // n = A,B,C,D,E,H,L,(HL),#
    //
    // Flags affected:
    // Z - Set if result is zero.
    // N - Reset.
    // H - Reset.
    // C - Reset.
    fn alu_or(&amp;mut self, n: u8) {
        let r = self.reg.a | n;
        self.reg.set_flag(C, false);
        self.reg.set_flag(H, false);
        self.reg.set_flag(N, false);
        self.reg.set_flag(Z, r == 0x00);
        self.reg.a = r;
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xb0 =&gt; self.alu_or(self.reg.b),
        0xb1 =&gt; self.alu_or(self.reg.c),
        0xb2 =&gt; self.alu_or(self.reg.d),
        0xb3 =&gt; self.alu_or(self.reg.e),
        0xb4 =&gt; self.alu_or(self.reg.h),
        0xb5 =&gt; self.alu_or(self.reg.l),
        0xb6 =&gt; {
            let a = self.mem.borrow().get(self.reg.get_hl());
            self.alu_or(a);
        }
        0xb7 =&gt; self.alu_or(self.reg.a),
        0xf6 =&gt; {
            let v = self.imm();
            self.alu_or(v);
        }
        ...
    }
}
</code></pre>

<p><strong>XOR A, r8/d8</strong></p>
<p>1) 描述</p>
<p>逻辑异或运算.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 计算结果为零, 则置位</li>
<li>N - 置零</li>
<li>H - 置零</li>
<li>C - 置零</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>XOR</td>
<td>B</td>
<td>0xa8</td>
<td>4</td>
</tr>
<tr>
<td>XOR</td>
<td>C</td>
<td>0xa9</td>
<td>4</td>
</tr>
<tr>
<td>XOR</td>
<td>D</td>
<td>0xaa</td>
<td>4</td>
</tr>
<tr>
<td>XOR</td>
<td>E</td>
<td>0xab</td>
<td>4</td>
</tr>
<tr>
<td>XOR</td>
<td>H</td>
<td>0xac</td>
<td>4</td>
</tr>
<tr>
<td>XOR</td>
<td>L</td>
<td>0xad</td>
<td>4</td>
</tr>
<tr>
<td>XOR</td>
<td>(HL)</td>
<td>0xae</td>
<td>8</td>
</tr>
<tr>
<td>XOR</td>
<td>A</td>
<td>0xaf</td>
<td>4</td>
</tr>
<tr>
<td>XOR</td>
<td>(d8)</td>
<td>0xee</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Logical exclusive OR n with register A, result in A.
    // n = A,B,C,D,E,H,L,(HL),#
    //
    // Flags affected:
    // Z - Set if result is zero.
    // N - Reset.
    // H - Reset.
    // C - Reset.
    fn alu_xor(&amp;mut self, n: u8) {
        let r = self.reg.a ^ n;
        self.reg.set_flag(C, false);
        self.reg.set_flag(H, false);
        self.reg.set_flag(N, false);
        self.reg.set_flag(Z, r == 0x00);
        self.reg.a = r;
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xa8 =&gt; self.alu_xor(self.reg.b),
        0xa9 =&gt; self.alu_xor(self.reg.c),
        0xaa =&gt; self.alu_xor(self.reg.d),
        0xab =&gt; self.alu_xor(self.reg.e),
        0xac =&gt; self.alu_xor(self.reg.h),
        0xad =&gt; self.alu_xor(self.reg.l),
        0xae =&gt; {
            let a = self.mem.borrow().get(self.reg.get_hl());
            self.alu_xor(a);
        }
        0xaf =&gt; self.alu_xor(self.reg.a),
        0xee =&gt; {
            let v = self.imm();
            self.alu_xor(v);
        }
        ...
    }
}
</code></pre>

<p><strong>CP A, r8/d8</strong></p>
<p>1) 描述</p>
<p>将寄存器 A 与相应 8 位数据进行比较. 该指令类似一个 A - n 减法指令, 但计算结果被丢弃了.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 计算结果为零, 则置位</li>
<li>N - 置位</li>
<li>H - 第 4 位借位时, 则置位</li>
<li>C - 没有发生借位, 则置位</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>CP</td>
<td>B</td>
<td>0xb8</td>
<td>4</td>
</tr>
<tr>
<td>CP</td>
<td>C</td>
<td>0xb9</td>
<td>4</td>
</tr>
<tr>
<td>CP</td>
<td>D</td>
<td>0xba</td>
<td>4</td>
</tr>
<tr>
<td>CP</td>
<td>E</td>
<td>0xbb</td>
<td>4</td>
</tr>
<tr>
<td>CP</td>
<td>H</td>
<td>0xbc</td>
<td>4</td>
</tr>
<tr>
<td>CP</td>
<td>L</td>
<td>0xbd</td>
<td>4</td>
</tr>
<tr>
<td>CP</td>
<td>(HL)</td>
<td>0xbe</td>
<td>8</td>
</tr>
<tr>
<td>CP</td>
<td>A</td>
<td>0xbf</td>
<td>4</td>
</tr>
<tr>
<td>CP</td>
<td>(d8)</td>
<td>0xfe</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Compare A with n. This is basically an A - n subtraction
    // instruction but the results are thrown away.
    // n = A,B,C,D,E,H,L,(HL),#
    //
    // Flags affected:
    // Z - Set if result is zero. (Set if A = n.)
    // N - Set.
    // H - Set if no borrow from bit 4.
    // C - Set for no borrow. (Set if A &lt; n.)
    fn alu_cp(&amp;mut self, n: u8) {
        let r = self.reg.a;
        self.alu_sub(n);
        self.reg.a = r;
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xb8 =&gt; self.alu_cp(self.reg.b),
        0xb9 =&gt; self.alu_cp(self.reg.c),
        0xba =&gt; self.alu_cp(self.reg.d),
        0xbb =&gt; self.alu_cp(self.reg.e),
        0xbc =&gt; self.alu_cp(self.reg.h),
        0xbd =&gt; self.alu_cp(self.reg.l),
        0xbe =&gt; {
            let a = self.mem.borrow().get(self.reg.get_hl());
            self.alu_cp(a);
        }
        0xbf =&gt; self.alu_cp(self.reg.a),
        0xfe =&gt; {
            let v = self.imm();
            self.alu_cp(v);
        }
        ...
    }
}
</code></pre>

<p><strong>INC r8</strong></p>
<p>1) 描述</p>
<p>相应 8 位寄存器自增.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 计算结果为零, 则置位</li>
<li>N - 置零</li>
<li>H - 第 3 位进位时, 则置位</li>
<li>C - 保持不变</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>INC</td>
<td>B</td>
<td>0x04</td>
<td>4</td>
</tr>
<tr>
<td>INC</td>
<td>C</td>
<td>0x0c</td>
<td>4</td>
</tr>
<tr>
<td>INC</td>
<td>D</td>
<td>0x14</td>
<td>4</td>
</tr>
<tr>
<td>INC</td>
<td>E</td>
<td>0x1c</td>
<td>4</td>
</tr>
<tr>
<td>INC</td>
<td>H</td>
<td>0x24</td>
<td>4</td>
</tr>
<tr>
<td>INC</td>
<td>L</td>
<td>0x2c</td>
<td>4</td>
</tr>
<tr>
<td>INC</td>
<td>(HL)</td>
<td>0x34</td>
<td>12</td>
</tr>
<tr>
<td>INC</td>
<td>A</td>
<td>0x3c</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Increment register n.
    // n = A,B,C,D,E,H,L,(HL)
    //
    // Flags affected:
    // Z - Set if result is zero.
    // N - Reset.
    // H - Set if carry from bit 3.
    // C - Not affected.
    fn alu_inc(&amp;mut self, a: u8) -&gt; u8 {
        let r = a.wrapping_add(1);
        self.reg.set_flag(H, (a &amp; 0x0f) + 0x01 &gt; 0x0f);
        self.reg.set_flag(N, false);
        self.reg.set_flag(Z, r == 0x00);
        r
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x04 =&gt; self.reg.b = self.alu_inc(self.reg.b),
        0x0c =&gt; self.reg.c = self.alu_inc(self.reg.c),
        0x14 =&gt; self.reg.d = self.alu_inc(self.reg.d),
        0x1c =&gt; self.reg.e = self.alu_inc(self.reg.e),
        0x24 =&gt; self.reg.h = self.alu_inc(self.reg.h),
        0x2c =&gt; self.reg.l = self.alu_inc(self.reg.l),
        0x34 =&gt; {
            let a = self.reg.get_hl();
            let v = self.mem.borrow().get(a);
            let h = self.alu_inc(v);
            self.mem.borrow_mut().set(a, h);
        }
        0x3c =&gt; self.reg.a = self.alu_inc(self.reg.a),
        ...
    }
}
</code></pre>

<p><strong>DEC r8</strong></p>
<p>1) 描述</p>
<p>相应 8 位寄存器自减.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 计算结果为零, 则置位</li>
<li>N - 置位</li>
<li>H - 第 4 位借位时, 则置位</li>
<li>C - 保持不变</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEC</td>
<td>B</td>
<td>0x05</td>
<td>4</td>
</tr>
<tr>
<td>DEC</td>
<td>C</td>
<td>0x0d</td>
<td>4</td>
</tr>
<tr>
<td>DEC</td>
<td>D</td>
<td>0x15</td>
<td>4</td>
</tr>
<tr>
<td>DEC</td>
<td>E</td>
<td>0x1d</td>
<td>4</td>
</tr>
<tr>
<td>DEC</td>
<td>H</td>
<td>0x25</td>
<td>4</td>
</tr>
<tr>
<td>DEC</td>
<td>L</td>
<td>0x2d</td>
<td>4</td>
</tr>
<tr>
<td>DEC</td>
<td>(HL)</td>
<td>0x35</td>
<td>12</td>
</tr>
<tr>
<td>DEC</td>
<td>A</td>
<td>0x3d</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Decrement register n.
    // n = A,B,C,D,E,H,L,(HL)
    //
    // Flags affected:
    // Z - Set if reselt is zero.
    // N - Set.
    // H - Set if no borrow from bit 4.
    // C - Not affected
    fn alu_dec(&amp;mut self, a: u8) -&gt; u8 {
        let r = a.wrapping_sub(1);
        self.reg.set_flag(H, a.trailing_zeros() &gt;= 4);
        self.reg.set_flag(N, true);
        self.reg.set_flag(Z, r == 0);
        r
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x05 =&gt; self.reg.b = self.alu_dec(self.reg.b),
        0x0d =&gt; self.reg.c = self.alu_dec(self.reg.c),
        0x15 =&gt; self.reg.d = self.alu_dec(self.reg.d),
        0x1d =&gt; self.reg.e = self.alu_dec(self.reg.e),
        0x25 =&gt; self.reg.h = self.alu_dec(self.reg.h),
        0x2d =&gt; self.reg.l = self.alu_dec(self.reg.l),
        0x35 =&gt; {
            let a = self.reg.get_hl();
            let v = self.mem.borrow().get(a);
            let h = self.alu_dec(v);
            self.mem.borrow_mut().set(a, h);
        }
        0x3d =&gt; self.reg.a = self.alu_dec(self.reg.a),
        ...
    }
}
</code></pre>

<h1 id="16_1">16 位算数逻辑运算</h1>
<p><strong>ADD HL, r16</strong></p>
<p>1) 描述</p>
<p>算数加法运算. 将寄存器 HL 与相应 16 位数据相加, 并将结果写入 HL.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 保持不变</li>
<li>N - 置零</li>
<li>H - 第 11 位进位时, 则置位</li>
<li>C - 第 15 位进位时, 则置位</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>ADD</td>
<td>(HL), BC</td>
<td>0x09</td>
<td>8</td>
</tr>
<tr>
<td>ADD</td>
<td>(HL), DE</td>
<td>0x19</td>
<td>8</td>
</tr>
<tr>
<td>ADD</td>
<td>(HL), HL</td>
<td>0x29</td>
<td>8</td>
</tr>
<tr>
<td>ADD</td>
<td>(HL), SP</td>
<td>0x39</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Add n to HL
    // n = BC,DE,HL,SP
    //
    // Flags affected:
    // Z - Not affected.
    // N - Reset.
    // H - Set if carry from bit 11.
    // C - Set if carry from bit 15.
    fn alu_add_hl(&amp;mut self, n: u16) {
        let a = self.reg.get_hl();
        let r = a.wrapping_add(n);
        self.reg.set_flag(C, a &gt; 0xffff - n);
        self.reg.set_flag(H, (a &amp; 0x0fff) + (n &amp; 0x0fff) &gt; 0x0fff);
        self.reg.set_flag(N, false);
        self.reg.set_hl(r);
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x09 =&gt; self.alu_add_hl(self.reg.get_bc()),
        0x19 =&gt; self.alu_add_hl(self.reg.get_de()),
        0x29 =&gt; self.alu_add_hl(self.reg.get_hl()),
        0x39 =&gt; self.alu_add_hl(self.reg.sp),
        ...
    }
}
</code></pre>

<p><strong>ADD SP, d8</strong></p>
<p>1) 描述</p>
<p>算数加法运算. 将寄存器 SP 与 8 位立即参数相加, 并将结果写入 SP. 立即参数以有符号 8 整数表示.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 置零</li>
<li>N - 置零</li>
<li>H - 第 4 位进位时, 则置位</li>
<li>C - 第 7 位进位时, 则置位</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>ADD</td>
<td>SP, (d8)</td>
<td>0xe8</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Add n to Stack Pointer (SP).
    // n = one byte signed immediate value (#).
    //
    // Flags affected:
    // Z - Reset.
    // N - Reset.
    // H - Set or reset according to operation.
    // C - Set or reset according to operation.
    fn alu_add_sp(&amp;mut self) {
        let a = self.reg.sp;
        let b = i16::from(self.imm() as i8) as u16;
        self.reg.set_flag(C, (a &amp; 0x00ff) + (b &amp; 0x00ff) &gt; 0x00ff);
        self.reg.set_flag(H, (a &amp; 0x000f) + (b &amp; 0x000f) &gt; 0x000f);
        self.reg.set_flag(N, false);
        self.reg.set_flag(Z, false);
        self.reg.sp = a.wrapping_add(b);
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xe8 =&gt; self.alu_add_sp(),
        ...
    }
}
</code></pre>

<p><strong>INC r16</strong></p>
<p>1) 描述</p>
<p>相应 16 位寄存器自增.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>INC</td>
<td>BC</td>
<td>0x03</td>
<td>8</td>
</tr>
<tr>
<td>INC</td>
<td>DE</td>
<td>0x13</td>
<td>8</td>
</tr>
<tr>
<td>INC</td>
<td>HL</td>
<td>0x23</td>
<td>8</td>
</tr>
<tr>
<td>INC</td>
<td>SP</td>
<td>0x33</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x03 =&gt; {
            let v = self.reg.get_bc().wrapping_add(1);
            self.reg.set_bc(v);
        }
        0x13 =&gt; {
            let v = self.reg.get_de().wrapping_add(1);
            self.reg.set_de(v);
        }
        0x23 =&gt; {
            let v = self.reg.get_hl().wrapping_add(1);
            self.reg.set_hl(v);
        }
        0x33 =&gt; {
            let v = self.reg.sp.wrapping_add(1);
            self.reg.sp = v;
        }
        ...
    }
}
</code></pre>

<p><strong>DEC r16</strong></p>
<p>1) 描述</p>
<p>相应 16 位寄存器自减.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEC</td>
<td>BC</td>
<td>0x0b</td>
<td>8</td>
</tr>
<tr>
<td>DEC</td>
<td>DE</td>
<td>0x1b</td>
<td>8</td>
</tr>
<tr>
<td>DEC</td>
<td>HL</td>
<td>0x2b</td>
<td>8</td>
</tr>
<tr>
<td>DEC</td>
<td>SP</td>
<td>0x3b</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x0b =&gt; {
            let v = self.reg.get_bc().wrapping_sub(1);
            self.reg.set_bc(v);
        }
        0x1b =&gt; {
            let v = self.reg.get_de().wrapping_sub(1);
            self.reg.set_de(v);
        }
        0x2b =&gt; {
            let v = self.reg.get_hl().wrapping_sub(1);
            self.reg.set_hl(v);
        }
        0x3b =&gt; {
            let v = self.reg.sp.wrapping_sub(1);
            self.reg.sp = v;
        }
        ...
    }
}
</code></pre>

<h1 id="_3">杂项</h1>
<p><strong>DAA</strong></p>
<p>1) 描述</p>
<p>该指令调整寄存器 A, 以便获得二进制编码十进制(BCD)的正确表示.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 计算结果为零, 则置位</li>
<li>N - 保持不变</li>
<li>H - 置零</li>
<li>C - 根据操作判断</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>DAA</td>
<td>-</td>
<td>0x27</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Decimal adjust register A. This instruction adjusts register
    // A so that the correct representation of Binary
    // Coded Decimal (BCD) is obtained.
    //
    // Flags affected:
    // Z - Set if register A is zero.
    // N - Not affected.
    // H - Reset.
    // C - Set or reset according to operation
    fn alu_daa(&amp;mut self) {
        let mut a = self.reg.a;
        let mut adjust = if self.reg.get_flag(C) { 0x60 } else { 0x00 };
        if self.reg.get_flag(H) {
            adjust |= 0x06;
        };
        if !self.reg.get_flag(N) {
            if a &amp; 0x0f &gt; 0x09 {
                adjust |= 0x06;
            };
            if a &gt; 0x99 {
                adjust |= 0x60;
            };
            a = a.wrapping_add(adjust);
        } else {
            a = a.wrapping_sub(adjust);
        }
        self.reg.set_flag(C, adjust &gt;= 0x60);
        self.reg.set_flag(H, false);
        self.reg.set_flag(Z, a == 0x00);
        self.reg.a = a;
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x27 =&gt; self.alu_daa(),
        ...
    }
}
</code></pre>

<p><strong>CPL</strong></p>
<p>1) 描述</p>
<p>对寄存器 A 取反.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 保持不变</li>
<li>N - 置位</li>
<li>H - 置位</li>
<li>C - 保持不变</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPL</td>
<td>-</td>
<td>0x2f</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Complement A register. (Flip all bits.)
    //
    // Flags affected:
    // Z - Not affected.
    // N - Set.
    // H - Set.
    // C - Not affected.
    fn alu_cpl(&amp;mut self) {
        self.reg.a = !self.reg.a;
        self.reg.set_flag(H, true);
        self.reg.set_flag(N, true);
    }
}


fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x2f =&gt; self.alu_cpl(),
        ...
    }
}
</code></pre>

<p><strong>CCF</strong></p>
<p>1) 描述</p>
<p>对进位标志位取反. 如果当前进位标志位为 1, 则置零；否则置位.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 保持不变</li>
<li>N - 置零</li>
<li>H - 置零</li>
<li>C - 取反</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>CCF</td>
<td>-</td>
<td>0x3f</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Complement carry flag. If C flag is set, then reset it.
    // If C flag is reset, then set it.
    // Flags affected:
    //
    // Z - Not affected.
    // N - Reset.
    // H - Reset.
    // C - Complemented.
    fn alu_ccf(&amp;mut self) {
        let v = !self.reg.get_flag(C);
        self.reg.set_flag(C, v);
        self.reg.set_flag(H, false);
        self.reg.set_flag(N, false);
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x3f =&gt; self.alu_ccf(),
        ...
    }
}
</code></pre>

<p><strong>SCF</strong></p>
<p>1) 描述</p>
<p>置位进位标志位.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 保持不变</li>
<li>N - 置零</li>
<li>H - 置零</li>
<li>C - 置位</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>SCF</td>
<td>-</td>
<td>0x37</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Set Carry flag.
    //
    // Flags affected:
    // Z - Not affected.
    // N - Reset.
    // H - Reset.
    // C - Set.
    fn alu_scf(&amp;mut self) {
        self.reg.set_flag(C, true);
        self.reg.set_flag(H, false);
        self.reg.set_flag(N, false);
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x37 =&gt; self.alu_scf(),
        ...
    }
}
</code></pre>

<p><strong>NOP</strong></p>
<p>1) 描述</p>
<p>不做操作.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>NOP</td>
<td>-</td>
<td>0x00</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x00 =&gt; {},
        ...
    }
}
</code></pre>

<p><strong>HALT</strong></p>
<p>1) 描述</p>
<p>关闭 CPU, 直到发生新的中断事件. 在程序开发中尽可能使用它可以降低能耗.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>HALT</td>
<td>-</td>
<td>0x76</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x76 =&gt; self.halted = true,
        ...
    }
}
</code></pre>

<p><strong>STOP</strong></p>
<p>1) 描述</p>
<p>在按下按钮之前暂停 CPU 和 LCD 显示. 仿真器实现时无需做特殊处理.</p>
<p>2) 标志位变化</p>
<p>无.</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>STOP</td>
<td>-</td>
<td>0x10</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x10 =&gt; {},
        ...
    }
}
</code></pre>

<p><strong>DI/EI</strong></p>
<p>1) 描述</p>
<p>DI(Disable Interrupt)指令禁用中断但不立即禁用. 执行 DI 后在下一个指令时禁用中断. EI(Enable Interrupt)指令启用中断, 该指令声明启用中断但不能立即执行. 执行 EI 后, 在下一个指令时启用中断.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>DI</td>
<td>-</td>
<td>0xf3</td>
<td>4</td>
</tr>
<tr>
<td>EI</td>
<td>-</td>
<td>0xfb</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xf3 =&gt; self.ei = false,
        0xfb =&gt; self.ei = true,
        ...
    }
}
</code></pre>

<h1 id="_4">循环和移位操作</h1>
<p>移位操作是位操作的一种. 移位运算可以在二进制的基础上对数字进行平移. 按照平移的方向和填充数字的规则分为多种: 左移, 带符号右移, 无符号右移, 循环左移, 循环右移等.</p>
<p>左移运算是将一个二进制位的操作数按指定移动的位数向左移动, 移出位被丢弃, 右边移出的空位一律补 0. 右移运算是将一个二进制位的操作数按指定移动的位数向右移动, 移出位被丢弃, 左边移出的空位一律补 0, 或者补符号位, 这由不同的机器而定. 在使用补码作为机器数的机器中, 正数的符号位为 0, 负数的符号位为 1.</p>
<p><strong>RLCA</strong></p>
<p>1) 描述</p>
<p>按位左移运算. 最高位移动至溢出标志位.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 计算结果为零, 则置位</li>
<li>N - 置零</li>
<li>H - 置零</li>
<li>C - 原始值的最高位.</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>RLCA</td>
<td>-</td>
<td>0x07</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Rotate A left. Old bit 7 to Carry flag.
    //
    // Flags affected:
    // Z - Set if result is zero.
    // N - Reset.
    // H - Reset.
    // C - Contains old bit 7 data.
    fn alu_rlc(&amp;mut self, a: u8) -&gt; u8 {
        let c = (a &amp; 0x80) &gt;&gt; 7 == 0x01;
        let r = (a &lt;&lt; 1) | u8::from(c);
        self.reg.set_flag(C, c);
        self.reg.set_flag(H, false);
        self.reg.set_flag(N, false);
        self.reg.set_flag(Z, r == 0x00);
        r
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x07 =&gt; {
            self.reg.a = self.alu_rlc(self.reg.a);
            self.reg.set_flag(Z, false);
        }
        ...
    }
}
</code></pre>

<p><strong>RLA</strong></p>
<p>1) 描述</p>
<p>按位左移运算. 溢出标志位补充最低位, 同时最高位移动至溢出标志位.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 计算结果为零, 则置位</li>
<li>N - 置零</li>
<li>H - 置零</li>
<li>C - 原始值的最高位.</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>RLA</td>
<td>-</td>
<td>0x17</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Rotate A left through Carry flag.
    //
    // Flags affected:
    // Z - Set if result is zero.
    // N - Reset.
    // H - Reset.
    // C - Contains old bit 7 data.
    fn alu_rl(&amp;mut self, a: u8) -&gt; u8 {
        let c = (a &amp; 0x80) &gt;&gt; 7 == 0x01;
        let r = (a &lt;&lt; 1) + u8::from(self.reg.get_flag(C));
        self.reg.set_flag(C, c);
        self.reg.set_flag(H, false);
        self.reg.set_flag(N, false);
        self.reg.set_flag(Z, r == 0x00);
        r
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x17 =&gt; {
            self.reg.a = self.alu_rl(self.reg.a);
            self.reg.set_flag(Z, false);
        }
        ...
    }
}
</code></pre>

<p><strong>RRCA</strong></p>
<p>1) 描述</p>
<p>按位右移运算. 最低位移动至溢出标志位.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 计算结果为零, 则置位</li>
<li>N - 置零</li>
<li>H - 置零</li>
<li>C - 原始值的最低位</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>RRCA</td>
<td>-</td>
<td>0x0f</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Rotate A right. Old bit 0 to Carry flag.
    //
    // Flags affected:
    // Z - Set if result is zero.
    // N - Reset.
    // H - Reset.
    // C - Contains old bit 0 data
    fn alu_rrc(&amp;mut self, a: u8) -&gt; u8 {
        let c = a &amp; 0x01 == 0x01;
        let r = if c { 0x80 | (a &gt;&gt; 1) } else { (a &gt;&gt; 1) };
        self.reg.set_flag(C, c);
        self.reg.set_flag(H, false);
        self.reg.set_flag(N, false);
        self.reg.set_flag(Z, r == 0x00);
        r
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x0f =&gt; {
            self.reg.a = self.alu_rrc(self.reg.a);
            self.reg.set_flag(Z, false);
        }
        ...
    }
}
</code></pre>

<p><strong>RRA</strong></p>
<p>1) 描述</p>
<p>按位右移运算. 溢出标志位移动至最高位, 同时最低位移动至溢出标志位.</p>
<p>2) 标志位变化</p>
<ul>
<li>Z - 计算结果为零, 则置位</li>
<li>N - 置零</li>
<li>H - 置零</li>
<li>C - 原始数据最低位</li>
</ul>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>RRA</td>
<td>-</td>
<td>0x1f</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">impl Cpu {
    // Rotate A right through Carry flag.
    //
    // Flags affected:
    // Z - Set if result is zero.
    // N - Reset.
    // H - Reset.
    // C - Contains old bit 0 data.
    fn alu_rr(&amp;mut self, a: u8) -&gt; u8 {
        let c = a &amp; 0x01 == 0x01;
        let r = if self.reg.get_flag(C) {
            0x80 | (a &gt;&gt; 1)
        } else {
            a &gt;&gt; 1
        };
        self.reg.set_flag(C, c);
        self.reg.set_flag(H, false);
        self.reg.set_flag(N, false);
        self.reg.set_flag(Z, r == 0x00);
        r
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x1f =&gt; {
            self.reg.a = self.alu_rr(self.reg.a);
            self.reg.set_flag(Z, false);
        }
        ...
    }
}
</code></pre>

<h1 id="_5">分支跳转</h1>
<p>在正式介绍 LR35902 的分支/跳转指令前, 先对该处理器的分支指令类型进行简单的介绍. 对于绝大部分处理器来说, 分支指令常常被分类为如下两类:</p>
<ul>
<li>无条件分支跳转. 该类型的指令是指无需判断条件一定会发生的跳转指令. 而按照跳转的目标地址计算方式, 还可以被分为以下两种情况:
    –   无条件直接地址跳转. 该类型的跳转目标地址是直接从指令编码的立即参数中获得的.
    –   无条件间接地址跳转. 该类型的跳转目标地址从寄存器中取得(或添加一定量的计算).</li>
<li>有条件分支跳转. 该类型的指令是指在跳转前需要判断条件是否成立而决定是否发生跳转的指令. 同样按照跳转的目标地址计算方式, 还可以被分为以下两种情况:
    –   带条件直接地址跳转. 该类型的跳转目标地址是直接从指令编码的立即参数中获得的.
    –   带条件间接地址跳转. 该类型的跳转目标地址从寄存器中取得(或添加一定量的计算).</li>
</ul>
<p>对于带条件分支/跳转指令而言, 是否发生跳转, 处理器将消耗不同的时钟周期. 理论上只有在执行阶段完成后, 才能够确切的解析出该指令消耗的时钟周期和目标跳转地址, 在仿真器的实现过程中需要特别注意.
对于现实世界的处理器而言, 为了提高性能, 在取指时会使用分支预测(Branch Prediction)技术. 该技术预测分支指令是否需要跳转以及跳转地址是什么, 也就是跳转的"方向"和"地址". 取指时对指令进行预测的方式被称为预测取指(Speculative Fetch), 对预取的指令进行执行也被称为预测执行(Speculative Exectution). 现代处理器已经可以非常高效的对分支进行预测, 预测正确率一般在 90% 到 99%.</p>
<p><strong>JUMP</strong></p>
<p>1)描述</p>
<p>跳转到指定的地址. 地址由 16 位立即参数指定.</p>
<p>2)标志位变化</p>
<p>无</p>
<p>3)指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>JUMP</td>
<td>(d16)</td>
<td>0xc3</td>
<td>12</td>
</tr>
</tbody>
</table>
<p>4)代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xc3 =&gt; self.reg.pc = self.imm_word(),
        0xe9 =&gt; self.reg.pc = self.reg.get_hl(),
        ...
    }
}
</code></pre>

<p><strong>JUMP IF</strong></p>
<p>1)描述</p>
<p>带条件的 JUMP 指令. 条件由下表指定.</p>
<p>2)标志位变化</p>
<p>无</p>
<p>3)指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>JUMP IF Z == 0</td>
<td>(d16)</td>
<td>0xc2</td>
<td>12</td>
</tr>
<tr>
<td>JUMP IF z != 0</td>
<td>(d16)</td>
<td>0xca</td>
<td>12</td>
</tr>
<tr>
<td>JUMP IF c ==  0</td>
<td>(d16)</td>
<td>0xd2</td>
<td>12</td>
</tr>
<tr>
<td>JUMP IF c != 0</td>
<td>(d16)</td>
<td>0xda</td>
<td>12</td>
</tr>
</tbody>
</table>
<p>4)代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xc2 | 0xca | 0xd2 | 0xda =&gt; {
            let pc = self.imm_word();
            let cond = match opcode {
                0xc2 =&gt; !self.reg.get_flag(Z),
                0xca =&gt; self.reg.get_flag(Z),
                0xd2 =&gt; !self.reg.get_flag(C),
                0xda =&gt; self.reg.get_flag(C),
                _ =&gt; panic!(&quot;&quot;),
            };
            if cond {
                self.reg.pc = pc;
            }
        }
        ...
    }
}
</code></pre>

<p><strong>JR</strong></p>
<p>1) 描述</p>
<p>读取一个 8 位有符号立即参数 n, 并跳转到 pc + n 位置.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>JR</td>
<td>(d8)</td>
<td>0x18</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4)代码实现</p>
<pre><code class="rs">impl Cpu {
    // Add n to current address and jump to it.
    // n = one byte signed immediate value
    fn alu_jr(&amp;mut self, n: u8) {
        let n = n as i8;
        self.reg.pc = ((u32::from(self.reg.pc) as i32) + i32::from(n)) as u16;
    }
}

fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x18 =&gt; {
            let n = self.imm();
            self.alu_jr(n);
        }
        ...
    }
}
</code></pre>

<p><strong>JR IF</strong></p>
<p>1) 描述</p>
<p>带条件的 JR 指令. 条件由下表指定.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>JR IF z == 0</td>
<td>-</td>
<td>0x20</td>
<td>8</td>
</tr>
<tr>
<td>JR IF z == 1</td>
<td>-</td>
<td>0x28</td>
<td>8</td>
</tr>
<tr>
<td>JR IF c == 0</td>
<td>-</td>
<td>0x30</td>
<td>8</td>
</tr>
<tr>
<td>JR IF c == 1</td>
<td>-</td>
<td>0x38</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4)代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0x20 | 0x28 | 0x30 | 0x38 =&gt; {
            let cond = match opcode {
                0x20 =&gt; !self.reg.get_flag(Z),
                0x28 =&gt; self.reg.get_flag(Z),
                0x30 =&gt; !self.reg.get_flag(C),
                0x38 =&gt; self.reg.get_flag(C),
                _ =&gt; panic!(&quot;&quot;),
            };
            let n = self.imm();
            if cond {
                self.alu_jr(n);
            }
        }
        ...
    }
}
</code></pre>

<h1 id="_6">调用</h1>
<p>调用命令通常泛指 CALL 类型的指令. 它们用于处理主程序与子程序之间的调用关系. 经典的主程序/子程序切换流程如下图所示.</p>
<p><img alt="img" src="/img/gameboy/cpu/lr35902_standard/call.png" /></p>
<p>子程序是用于完成特定功能的一段程序. 当主程序(调用程序)需要执行这个功能时, 采用 CALL 调用指令转移到该子程序的起始处执行. 当运行完子程序功能后, 采用 RET 返回指令回到主程序继续执行.</p>
<p><strong>CALL</strong></p>
<p>1) 描述</p>
<p>将下一条指令的地址压入堆栈, 并跳转到相应地址(由 16 位立即参数指定). 类似高级语言中的函数调用.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>CALL</td>
<td>-</td>
<td>0xcd</td>
<td>12</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xcd =&gt; {
            let nn = self.imm_word();
            self.stack_add(self.reg.pc);
            self.reg.pc = nn;
        }
        ...
    }
}
</code></pre>

<p><strong>CALL IF</strong></p>
<p>1) 描述</p>
<p>带条件的 CALL 指令. 条件由下表指定.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>CALL IF z == 0</td>
<td>-</td>
<td>0xc4</td>
<td>12</td>
</tr>
<tr>
<td>CALL IF z == 1</td>
<td>-</td>
<td>0xcc</td>
<td>12</td>
</tr>
<tr>
<td>CALL IF c == 0</td>
<td>-</td>
<td>0xd4</td>
<td>12</td>
</tr>
<tr>
<td>CALL IF c == 1</td>
<td>-</td>
<td>0xdc</td>
<td>12</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xc4 | 0xcc | 0xd4 | 0xdc =&gt; {
            let cond = match opcode {
                0xc4 =&gt; !self.reg.get_flag(Z),
                0xcc =&gt; self.reg.get_flag(Z),
                0xd4 =&gt; !self.reg.get_flag(C),
                0xdc =&gt; self.reg.get_flag(C),
                _ =&gt; panic!(&quot;&quot;),
            };
            let nn = self.imm_word();
            if cond {
                self.stack_add(self.reg.pc);
                self.reg.pc = nn;
            }
        }
        ...
    }
}
</code></pre>

<h1 id="_7">复位</h1>
<p><strong>RST</strong></p>
<p>1) 描述</p>
<p>将当前地址推送到堆栈, 并跳转到某个固定地址. 地址见下表.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>RST</td>
<td>0x00</td>
<td>0xc7</td>
<td>32</td>
</tr>
<tr>
<td>RST</td>
<td>0x08</td>
<td>0xcf</td>
<td>32</td>
</tr>
<tr>
<td>RST</td>
<td>0x10</td>
<td>0xd7</td>
<td>32</td>
</tr>
<tr>
<td>RST</td>
<td>0x18</td>
<td>0xdf</td>
<td>32</td>
</tr>
<tr>
<td>RST</td>
<td>0x20</td>
<td>0xe7</td>
<td>32</td>
</tr>
<tr>
<td>RST</td>
<td>0x28</td>
<td>0xef</td>
<td>32</td>
</tr>
<tr>
<td>RST</td>
<td>0x30</td>
<td>0xf7</td>
<td>32</td>
</tr>
<tr>
<td>RST</td>
<td>0x38</td>
<td>0xcf</td>
<td>32</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xc7 =&gt; {
            self.stack_add(self.reg.pc);
            self.reg.pc = 0x00;
        }
        0xcf =&gt; {
            self.stack_add(self.reg.pc);
            self.reg.pc = 0x08;
        }
        0xd7 =&gt; {
            self.stack_add(self.reg.pc);
            self.reg.pc = 0x10;
        }
        0xdf =&gt; {
            self.stack_add(self.reg.pc);
            self.reg.pc = 0x18;
        }
        0xe7 =&gt; {
            self.stack_add(self.reg.pc);
            self.reg.pc = 0x20;
        }
        0xef =&gt; {
            self.stack_add(self.reg.pc);
            self.reg.pc = 0x28;
        }
        0xf7 =&gt; {
            self.stack_add(self.reg.pc);
            self.reg.pc = 0x30;
        }
        0xff =&gt; {
            self.stack_add(self.reg.pc);
            self.reg.pc = 0x38;
        }
        ...
    }
}
</code></pre>

<h1 id="_8">返回</h1>
<p><strong>RET</strong></p>
<p>1) 描述</p>
<p>从堆栈中弹出一个 16 位地址, 并跳转到该地址. 它类似高级语言中的 Return 语句.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>RET</td>
<td>-</td>
<td>0xc9</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xc9 =&gt; self.reg.pc = self.stack_pop(),
        ...
    }
}
</code></pre>

<p><strong>RET IF</strong></p>
<p>1) 描述</p>
<p>带条件的 RET 指令. 条件由下表指定.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>RET IF z == 0</td>
<td>-</td>
<td>0xc0</td>
<td>8</td>
</tr>
<tr>
<td>RET IF z == 1</td>
<td>-</td>
<td>0xc8</td>
<td>8</td>
</tr>
<tr>
<td>RET IF c == 0</td>
<td>-</td>
<td>0xd0</td>
<td>8</td>
</tr>
<tr>
<td>RET IF c == 1</td>
<td>-</td>
<td>0xd8</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xc0 | 0xc8 | 0xd0 | 0xd8 =&gt; {
            let cond = match opcode {
                0xc0 =&gt; !self.reg.get_flag(Z),
                0xc8 =&gt; self.reg.get_flag(Z),
                0xd0 =&gt; !self.reg.get_flag(C),
                0xd8 =&gt; self.reg.get_flag(C),
                _ =&gt; panic!(&quot;&quot;),
            };
            if cond {
                self.reg.pc = self.stack_pop();
            }
        }
        ...
    }
}
</code></pre>

<p><strong>RETI</strong></p>
<p>1) 描述</p>
<p>执行 RET 指令并启用中断.</p>
<p>2) 标志位变化</p>
<p>无</p>
<p>3) 指令</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Parameters</th>
<th>Opcode</th>
<th>Cycles</th>
</tr>
</thead>
<tbody>
<tr>
<td>RETI</td>
<td>_</td>
<td>0xd9</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>4) 代码实现</p>
<pre><code class="rs">fn ex(&amp;mut self) -&gt; u32 {
    let opcode = self.imm();
    match opcode {
        0xd9 =&gt; {
            self.reg.pc = self.stack_pop();
            self.ei = true;
        }
        ...
    }
}
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../lr35902_extension/" class="btn btn-neutral float-right" title="GB-CPU-LR35902扩展指令集">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../pipeline/" class="btn btn-neutral" title="GB-CPU-流水线"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/mohanson/accu/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../pipeline/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../lr35902_extension/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    
    <script>var base_url = '../../../..';</script>
    <script src="../../../../js/theme.js" defer></script>
      <script src="../../../../js/accu.js" defer></script>
      <script src="../../../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>


</body>
</html>
